package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class rt_cmsis_template
{
  protected static String nl;
  public static synchronized rt_cmsis_template create(String lineSeparator)
  {
    nl = lineSeparator;
    rt_cmsis_template result = new rt_cmsis_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "/*----------------------------------------------------------------------------" + NL + " *      RL-ARM - RTX" + NL + " *----------------------------------------------------------------------------" + NL + " *      Name:    rt_CMSIS.c" + NL + " *      Purpose: CMSIS RTOS API" + NL + " *      Rev.:    V4.74" + NL + " *----------------------------------------------------------------------------" + NL + " *" + NL + " * Copyright (c) 1999-2009 KEIL, 2009-2013 ARM Germany GmbH" + NL + " * All rights reserved." + NL + " * Redistribution and use in source and binary forms, with or without" + NL + " * modification, are permitted provided that the following conditions are met:" + NL + " *  - Redistributions of source code must retain the above copyright" + NL + " *    notice, this list of conditions and the following disclaimer." + NL + " *  - Redistributions in binary form must reproduce the above copyright" + NL + " *    notice, this list of conditions and the following disclaimer in the" + NL + " *    documentation and/or other materials provided with the distribution." + NL + " *  - Neither the name of ARM  nor the names of its contributors may be used " + NL + " *    to endorse or promote products derived from this software without " + NL + " *    specific prior written permission." + NL + " *" + NL + " * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" " + NL + " * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE " + NL + " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE" + NL + " * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE" + NL + " * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR" + NL + " * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF " + NL + " * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS " + NL + " * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN " + NL + " * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) " + NL + " * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE" + NL + " * POSSIBILITY OF SUCH DAMAGE." + NL + " *---------------------------------------------------------------------------*/" + NL + "" + NL + "#ifdef __GNUC__" + NL + "#pragma GCC optimize(\"-O1\")" + NL + "#endif" + NL + "" + NL + "#define __CMSIS_GENERIC" + NL;
  protected final String TEXT_2 = NL + "#ifndef __FPU_PRESENT" + NL + "#define __FPU_PRESENT 1" + NL + "#endif" + NL + "#include \"core_cm4.h\"";
  protected final String TEXT_3 = NL + "#include \"core_cm0.h\"";
  protected final String TEXT_4 = NL + " " + NL + "#include \"rt_TypeDef.h\"" + NL + "#include \"RTX_Config.h\"" + NL + "#include \"rt_System.h\"" + NL + "#include \"rt_Task.h\"" + NL + "#include \"rt_Event.h\"" + NL + "#include \"rt_List.h\"" + NL + "#include \"rt_Time.h\"" + NL + "#include \"rt_Mutex.h\"" + NL + "#include \"rt_Semaphore.h\"" + NL + "#include \"rt_Mailbox.h\"" + NL + "#include \"rt_MemBox.h\"" + NL + "#include \"rt_Memory.h\"" + NL + "#include \"rt_HAL_CM.h\"" + NL + "" + NL + "#define os_thread_cb OS_TCB" + NL + "" + NL + "#include \"../INC/cmsis_os.h\"" + NL + "" + NL + "#if (osFeature_Signals != 16)" + NL + "#error Invalid \"osFeature_Signals\" value!" + NL + "#endif" + NL + "#if (osFeature_Semaphore > 65535)" + NL + "#error Invalid \"osFeature_Semaphore\" value!" + NL + "#endif" + NL + "#if (osFeature_Wait != 0)" + NL + "#error osWait not supported!" + NL + "#endif" + NL + "" + NL + "" + NL + "// ==== Enumeration, structures, defines ====" + NL + "" + NL + "// Service Calls defines" + NL + "" + NL + "#if defined (__CC_ARM)          /* ARM Compiler */" + NL + "" + NL + "#define __NO_RETURN __declspec(noreturn)" + NL + "" + NL + "#define osEvent_type       osEvent" + NL + "#define osEvent_ret_status ret" + NL + "#define osEvent_ret_value  ret" + NL + "#define osEvent_ret_msg    ret" + NL + "#define osEvent_ret_mail   ret" + NL + "" + NL + "#define osCallback_type    osCallback" + NL + "#define osCallback_ret     ret" + NL + "" + NL + "#define SVC_0_1(f,t,...)                                                       \\" + NL + "__svc_indirect(0) t  _##f (t(*)());                                            \\" + NL + "                  t     f (void);                                              \\" + NL + "__attribute__((always_inline))                                                 \\" + NL + "static __inline   t __##f (void) {                                             \\" + NL + "  return _##f(f);                                                              \\" + NL + "}" + NL + "" + NL + "#define SVC_1_0(f,t,t1,...)                                                    \\" + NL + "__svc_indirect(0) t  _##f (t(*)(t1),t1);                                       \\" + NL + "                  t     f (t1 a1);                                             \\" + NL + "__attribute__((always_inline))                                                 \\" + NL + "static __inline   t __##f (t1 a1) {                                            \\" + NL + "  _##f(f,a1);                                                                  \\" + NL + "}" + NL + "" + NL + "#define SVC_1_1(f,t,t1,...)                                                    \\" + NL + "__svc_indirect(0) t  _##f (t(*)(t1),t1);                                       \\" + NL + "                  t     f (t1 a1);                                             \\" + NL + "__attribute__((always_inline))                                                 \\" + NL + "static __inline   t __##f (t1 a1) {                                            \\" + NL + "  return _##f(f,a1);                                                           \\" + NL + "}" + NL + "" + NL + "#define SVC_2_1(f,t,t1,t2,...)                                                 \\" + NL + "__svc_indirect(0) t  _##f (t(*)(t1,t2),t1,t2);                                 \\" + NL + "                  t     f (t1 a1, t2 a2);                                      \\" + NL + "__attribute__((always_inline))                                                 \\" + NL + "static __inline   t __##f (t1 a1, t2 a2) {                                     \\" + NL + "  return _##f(f,a1,a2);                                                        \\" + NL + "}" + NL + "" + NL + "#define SVC_3_1(f,t,t1,t2,t3,...)                                              \\" + NL + "__svc_indirect(0) t  _##f (t(*)(t1,t2,t3),t1,t2,t3);                           \\" + NL + "                  t     f (t1 a1, t2 a2, t3 a3);                               \\" + NL + "__attribute__((always_inline))                                                 \\" + NL + "static __inline   t __##f (t1 a1, t2 a2, t3 a3) {                              \\" + NL + "  return _##f(f,a1,a2,a3);                                                     \\" + NL + "}" + NL + "" + NL + "#define SVC_4_1(f,t,t1,t2,t3,t4,...)                                           \\" + NL + "__svc_indirect(0) t  _##f (t(*)(t1,t2,t3,t4),t1,t2,t3,t4);                     \\" + NL + "                  t     f (t1 a1, t2 a2, t3 a3, t4 a4);                        \\" + NL + "__attribute__((always_inline))                                                 \\" + NL + "static __inline   t __##f (t1 a1, t2 a2, t3 a3, t4 a4) {                       \\" + NL + "  return _##f(f,a1,a2,a3,a4);                                                  \\" + NL + "}" + NL + "" + NL + "#define SVC_1_2 SVC_1_1 " + NL + "#define SVC_1_3 SVC_1_1 " + NL + "#define SVC_2_3 SVC_2_1 " + NL + "" + NL + "#elif defined (__GNUC__)        /* GNU Compiler */" + NL + "" + NL + "#define __NO_RETURN __attribute__((noreturn))" + NL + "" + NL + "typedef uint32_t __attribute__((vector_size(8)))  ret64;" + NL + "typedef uint32_t __attribute__((vector_size(16))) ret128;" + NL + "" + NL + "#define RET_pointer    __r0" + NL + "#define RET_int32_t    __r0" + NL + "#define RET_uint32_t   __r0" + NL + "#define RET_osStatus   __r0" + NL + "#define RET_osPriority __r0" + NL + "#define RET_osEvent    {(osStatus)__r0, {(uint32_t)__r1}, {(void *)__r2}}" + NL + "#define RET_osCallback {(void *)__r0, (void *)__r1}" + NL + "" + NL + "#define osEvent_type        ret128" + NL + "#define osEvent_ret_status (ret128){ret.status}" + NL + "#define osEvent_ret_value  (ret128){ret.status, ret.value.v}" + NL + "#define osEvent_ret_msg    (ret128){ret.status, ret.value.v, (uint32_t)ret.def.message_id}" + NL + "#define osEvent_ret_mail   (ret128){ret.status, ret.value.v, (uint32_t)ret.def.mail_id}" + NL + "" + NL + "#define osCallback_type     ret64" + NL + "#define osCallback_ret     (ret64) {(uint32_t)ret.fp, (uint32_t)ret.arg}" + NL + "" + NL + "#define SVC_ArgN(n) \\" + NL + "  register int __r##n __asm(\"r\"#n);" + NL + "" + NL + "#define SVC_ArgR(n,t,a) \\" + NL + "  register t   __r##n __asm(\"r\"#n) = a;" + NL + "" + NL + "#define SVC_Arg0()                                                             \\" + NL + "  SVC_ArgN(0)                                                                  \\" + NL + "  SVC_ArgN(1)                                                                  \\" + NL + "  SVC_ArgN(2)                                                                  \\" + NL + "  SVC_ArgN(3)" + NL + "" + NL + "#define SVC_Arg1(t1)                                                           \\" + NL + "  SVC_ArgR(0,t1,a1)                                                            \\" + NL + "  SVC_ArgN(1)                                                                  \\" + NL + "  SVC_ArgN(2)                                                                  \\" + NL + "  SVC_ArgN(3)" + NL + "" + NL + "#define SVC_Arg2(t1,t2)                                                        \\" + NL + "  SVC_ArgR(0,t1,a1)                                                            \\" + NL + "  SVC_ArgR(1,t2,a2)                                                            \\" + NL + "  SVC_ArgN(2)                                                                  \\" + NL + "  SVC_ArgN(3)" + NL + "" + NL + "#define SVC_Arg3(t1,t2,t3)                                                     \\" + NL + "  SVC_ArgR(0,t1,a1)                                                            \\" + NL + "  SVC_ArgR(1,t2,a2)                                                            \\" + NL + "  SVC_ArgR(2,t3,a3)                                                            \\" + NL + "  SVC_ArgN(3)" + NL + "" + NL + "#define SVC_Arg4(t1,t2,t3,t4)                                                  \\" + NL + "  SVC_ArgR(0,t1,a1)                                                            \\" + NL + "  SVC_ArgR(1,t2,a2)                                                            \\" + NL + "  SVC_ArgR(2,t3,a3)                                                            \\" + NL + "  SVC_ArgR(3,t4,a4)" + NL + "" + NL + "#if (defined (__CORTEX_M0))" + NL + "#define SVC_Call(f)                                                            \\" + NL + "  __asm volatile                                                               \\" + NL + "  (                                                                            \\" + NL + "    \"ldr r7,=\"#f\"\\n\\t\"                                                         \\" + NL + "    \"mov r12,r7\\n\\t\"                                                           \\" + NL + "    \"svc 0\"                                                                    \\" + NL + "    :               \"=r\" (__r0), \"=r\" (__r1), \"=r\" (__r2), \"=r\" (__r3)         \\" + NL + "    :                \"r\" (__r0),  \"r\" (__r1),  \"r\" (__r2),  \"r\" (__r3)         \\" + NL + "    : \"r7\", \"r12\", \"lr\", \"cc\"                                                  \\" + NL + "  );" + NL + "#else" + NL + "#define SVC_Call(f)                                                            \\" + NL + "  __asm volatile                                                               \\" + NL + "  (                                                                            \\" + NL + "    \"ldr r12,=\"#f\"\\n\\t\"                                                        \\" + NL + "    \"svc 0\"                                                                    \\" + NL + "    :               \"=r\" (__r0), \"=r\" (__r1), \"=r\" (__r2), \"=r\" (__r3)         \\" + NL + "    :                \"r\" (__r0),  \"r\" (__r1),  \"r\" (__r2),  \"r\" (__r3)         \\" + NL + "    : \"r12\", \"lr\", \"cc\"                                                        \\" + NL + "  );" + NL + "#endif" + NL + "" + NL + "#define SVC_0_1(f,t,rv)                                                        \\" + NL + "__attribute__((always_inline))                                                 \\" + NL + "static inline  t __##f (void) {                                                \\" + NL + "  SVC_Arg0();                                                                  \\" + NL + "  SVC_Call(f);                                                                 \\" + NL + "  return (t) rv;                                                               \\" + NL + "}" + NL + "" + NL + "#define SVC_1_0(f,t,t1)                                                        \\" + NL + "__attribute__((always_inline))                                                 \\" + NL + "static inline  t __##f (t1 a1) {                                               \\" + NL + "  SVC_Arg1(t1);                                                                \\" + NL + "  SVC_Call(f);                                                                 \\" + NL + "}" + NL + "" + NL + "#define SVC_1_1(f,t,t1,rv)                                                     \\" + NL + "__attribute__((always_inline))                                                 \\" + NL + "static inline  t __##f (t1 a1) {                                               \\" + NL + "  SVC_Arg1(t1);                                                                \\" + NL + "  SVC_Call(f);                                                                 \\" + NL + "  return (t) rv;                                                               \\" + NL + "}" + NL + "" + NL + "#define SVC_2_1(f,t,t1,t2,rv)                                                  \\" + NL + "__attribute__((always_inline))                                                 \\" + NL + "static inline  t __##f (t1 a1, t2 a2) {                                        \\" + NL + "  SVC_Arg2(t1,t2);                                                             \\" + NL + "  SVC_Call(f);                                                                 \\" + NL + "  return (t) rv;                                                               \\" + NL + "}" + NL + "" + NL + "#define SVC_3_1(f,t,t1,t2,t3,rv)                                               \\" + NL + "__attribute__((always_inline))                                                 \\" + NL + "static inline  t __##f (t1 a1, t2 a2, t3 a3) {                                 \\" + NL + "  SVC_Arg3(t1,t2,t3);                                                          \\" + NL + "  SVC_Call(f);                                                                 \\" + NL + "  return (t) rv;                                                               \\" + NL + "}" + NL + "" + NL + "#define SVC_4_1(f,t,t1,t2,t3,t4,rv)                                            \\" + NL + "__attribute__((always_inline))                                                 \\" + NL + "static inline  t __##f (t1 a1, t2 a2, t3 a3, t4 a4) {                          \\" + NL + "  SVC_Arg4(t1,t2,t3,t4);                                                       \\" + NL + "  SVC_Call(f);                                                                 \\" + NL + "  return (t) rv;                                                               \\" + NL + "}" + NL + "" + NL + "#define SVC_1_2 SVC_1_1 " + NL + "#define SVC_1_3 SVC_1_1 " + NL + "#define SVC_2_3 SVC_2_1 " + NL + "" + NL + "#elif defined (__ICCARM__)      /* IAR Compiler */" + NL + "" + NL + "#define __NO_RETURN __noreturn" + NL + "" + NL + "#define RET_osEvent        \"=r\"(ret.status), \"=r\"(ret.value), \"=r\"(ret.def)" + NL + "#define RET_osCallback     \"=r\"(ret.fp), \"=r\"(ret.arg)" + NL + "" + NL + "#define osEvent_type       osEvent" + NL + "#define osEvent_ret_status ret" + NL + "#define osEvent_ret_value  ret" + NL + "#define osEvent_ret_msg    ret" + NL + "#define osEvent_ret_mail   ret" + NL + "" + NL + "#define osCallback_type    uint64_t" + NL + "#define osCallback_ret     ((uint64_t)ret.fp | ((uint64_t)ret.arg)<<32)" + NL + "" + NL + "#define SVC_Setup(f)                                                           \\" + NL + "  __asm(                                                                       \\" + NL + "    \"mov r12,%0\\n\"                                                             \\" + NL + "    :: \"r\"(&f): \"r12\"                                                          \\" + NL + "  );" + NL + "" + NL + "#define SVC_Ret3()                                                             \\" + NL + "  __asm(                                                                       \\" + NL + "    \"ldr r0,[sp,#0]\\n\"                                                         \\" + NL + "    \"ldr r1,[sp,#4]\\n\"                                                         \\" + NL + "    \"ldr r2,[sp,#8]\\n\"                                                         \\" + NL + "  );" + NL + "" + NL + "#define SVC_0_1(f,t,...)                                                       \\" + NL + "t f (void);                                                                    \\" + NL + "_Pragma(\"swi_number=0\") __swi t _##f (void);                                   \\" + NL + "static inline t __##f (void) {                                                 \\" + NL + "  SVC_Setup(f);                                                                \\" + NL + "  return _##f();                                                               \\" + NL + "}" + NL + "" + NL + "#define SVC_1_0(f,t,t1,...)                                                    \\" + NL + "t f (t1 a1);                                                                   \\" + NL + "_Pragma(\"swi_number=0\") __swi t _##f (t1 a1);                                  \\" + NL + "static inline t __##f (t1 a1) {                                                \\" + NL + "  SVC_Setup(f);                                                                \\" + NL + "  _##f(a1);                                                                    \\" + NL + "}" + NL + "" + NL + "#define SVC_1_1(f,t,t1,...)                                                    \\" + NL + "t f (t1 a1);                                                                   \\" + NL + "_Pragma(\"swi_number=0\") __swi t _##f (t1 a1);                                  \\" + NL + "static inline t __##f (t1 a1) {                                                \\" + NL + "  SVC_Setup(f);                                                                \\" + NL + "  return _##f(a1);                                                             \\" + NL + "}" + NL + "" + NL + "#define SVC_2_1(f,t,t1,t2,...)                                                 \\" + NL + "t f (t1 a1, t2 a2);                                                            \\" + NL + "_Pragma(\"swi_number=0\") __swi t _##f (t1 a1, t2 a2);                           \\" + NL + "static inline t __##f (t1 a1, t2 a2) {                                         \\" + NL + "  SVC_Setup(f);                                                                \\" + NL + "  return _##f(a1,a2);                                                          \\" + NL + "}" + NL + "" + NL + "#define SVC_3_1(f,t,t1,t2,t3,...)                                              \\" + NL + "t f (t1 a1, t2 a2, t3 a3);                                                     \\" + NL + "_Pragma(\"swi_number=0\") __swi t _##f (t1 a1, t2 a2, t3 a3);                    \\" + NL + "static inline t __##f (t1 a1, t2 a2, t3 a3) {                                  \\" + NL + "  SVC_Setup(f);                                                                \\" + NL + "  return _##f(a1,a2,a3);                                                       \\" + NL + "}" + NL + "" + NL + "#define SVC_4_1(f,t,t1,t2,t3,t4,...)                                           \\" + NL + "t f (t1 a1, t2 a2, t3 a3, t4 a4);                                              \\" + NL + "_Pragma(\"swi_number=0\") __swi t _##f (t1 a1, t2 a2, t3 a3, t4 a4);             \\" + NL + "static inline t __##f (t1 a1, t2 a2, t3 a3, t4 a4) {                           \\" + NL + "  SVC_Setup(f);                                                                \\" + NL + "  return _##f(a1,a2,a3,a4);                                                    \\" + NL + "}" + NL + "" + NL + "#define SVC_1_2(f,t,t1,rr)                                                     \\" + NL + "uint64_t f (t1 a1);                                                            \\" + NL + "_Pragma(\"swi_number=0\") __swi uint64_t _##f (t1 a1);                           \\" + NL + "static inline t __##f (t1 a1) {                                                \\" + NL + "  t ret;                                                                       \\" + NL + "  SVC_Setup(f);                                                                \\" + NL + "  _##f(a1);                                                                    \\" + NL + "  __asm(\"\" : rr : :);                                                          \\" + NL + "  return ret;                                                                  \\" + NL + "}" + NL + "" + NL + "#define SVC_1_3(f,t,t1,rr)                                                     \\" + NL + "t f (t1 a1);                                                                   \\" + NL + "void f##_ (t1 a1) {                                                            \\" + NL + "  f(a1);                                                                       \\" + NL + "  SVC_Ret3();                                                                  \\" + NL + "}                                                                              \\" + NL + "_Pragma(\"swi_number=0\") __swi void _##f (t1 a1);                               \\" + NL + "static inline t __##f (t1 a1) {                                                \\" + NL + "  t ret;                                                                       \\" + NL + "  SVC_Setup(f##_);                                                             \\" + NL + "  _##f(a1);                                                                    \\" + NL + "  __asm(\"\" : rr : :);                                                          \\" + NL + "  return ret;                                                                  \\" + NL + "}" + NL + "" + NL + "#define SVC_2_3(f,t,t1,t2,rr)                                                  \\" + NL + "t f (t1 a1, t2 a2);                                                            \\" + NL + "void f##_ (t1 a1, t2 a2) {                                                     \\" + NL + "  f(a1,a2);                                                                    \\" + NL + "  SVC_Ret3();                                                                  \\" + NL + "}                                                                              \\" + NL + "_Pragma(\"swi_number=0\") __swi void _##f (t1 a1, t2 a2);                        \\" + NL + "static inline t __##f (t1 a1, t2 a2) {                                         \\" + NL + "  t ret;                                                                       \\" + NL + "  SVC_Setup(f##_);                                                             \\" + NL + "  _##f(a1,a2);                                                                 \\" + NL + "  __asm(\"\" : rr : :);                                                          \\" + NL + "  return ret;                                                                  \\" + NL + "}" + NL + "" + NL + "#endif" + NL + "" + NL + "" + NL + "// Callback structure" + NL + "typedef struct {" + NL + "  void *fp;             // Function pointer" + NL + "  void *arg;            // Function argument" + NL + "} osCallback;" + NL + "" + NL + "" + NL + "// OS Section definitions" + NL + "#ifdef OS_SECTIONS_LINK_INFO" + NL + "extern const uint32_t  os_section_id$$Base;" + NL + "extern const uint32_t  os_section_id$$Limit;" + NL + "#endif" + NL + "" + NL + "// OS Stack Memory for Threads definitions" + NL + "extern       uint64_t  os_stack_mem[];" + NL + "extern const uint32_t  os_stack_sz;" + NL + "" + NL + "// OS Timers external resources" + NL + "extern const osThreadDef_t   os_thread_def_osTimerThread;" + NL + "extern       osThreadId      osThreadId_osTimerThread;" + NL + "extern const osMessageQDef_t os_messageQ_def_osTimerMessageQ;" + NL + "extern       osMessageQId    osMessageQId_osTimerMessageQ;" + NL + "" + NL + "" + NL + "// ==== Helper Functions ====" + NL + "" + NL + "/// Convert timeout in millisec to system ticks" + NL + "static uint32_t rt_ms2tick (uint32_t millisec) {" + NL + "  uint32_t tick;" + NL + "" + NL + "  if (millisec == osWaitForever) return 0xFFFF; // Indefinite timeout" + NL + "  if (millisec > 4000000) return 0xFFFE;        // Max ticks supported" + NL + "" + NL + "  tick = ((1000 * millisec) + os_clockrate - 1)  / os_clockrate;" + NL + "  if (tick > 0xFFFE) return 0xFFFE;" + NL + "  " + NL + "  return tick;" + NL + "}" + NL + "" + NL + "/// Convert Thread ID to TCB pointer" + NL + "static P_TCB rt_tid2ptcb (osThreadId thread_id) {" + NL + "  P_TCB ptcb;" + NL + "" + NL + "  if (thread_id == NULL) return NULL;" + NL + "" + NL + "  if ((uint32_t)thread_id & 3) return NULL;" + NL + NL;
  protected final String TEXT_5 = "#ifdef OS_SECTIONS_LINK_INFO" + NL + "  if ((os_section_id$$Base != 0) && (os_section_id$$Limit != 0)) {" + NL + "    if (thread_id  < (osThreadId)os_section_id$$Base)  return NULL;" + NL + "    if (thread_id >= (osThreadId)os_section_id$$Limit) return NULL;" + NL + "  }" + NL + "#endif" + NL + "" + NL + "  ptcb = thread_id;" + NL + "" + NL + "  if (ptcb->cb_type != TCB) return NULL;" + NL + "" + NL + "  return ptcb;" + NL + "}" + NL + "" + NL + "/// Convert ID pointer to Object pointer" + NL + "static void *rt_id2obj (void *id) {" + NL + "" + NL + "  if ((uint32_t)id & 3) return NULL;" + NL + "" + NL + "#ifdef OS_SECTIONS_LINK_INFO" + NL + "  if ((os_section_id$$Base != 0) && (os_section_id$$Limit != 0)) {" + NL + "    if (id  < (void *)os_section_id$$Base)  return NULL;" + NL + "    if (id >= (void *)os_section_id$$Limit) return NULL;" + NL + "  }" + NL + "#endif" + NL + "" + NL + "  return id;" + NL + "}" + NL + "" + NL + "" + NL + "// ==== Kernel Control ====" + NL + "" + NL + "uint8_t os_initialized;                         // Kernel Initialized flag" + NL + "uint8_t os_running;                             // Kernel Running flag" + NL + "" + NL + "// Kernel Control Service Calls declarations" + NL + "SVC_0_1(svcKernelInitialize, osStatus, RET_osStatus)" + NL + "SVC_0_1(svcKernelStart,      osStatus, RET_osStatus)" + NL + "SVC_0_1(svcKernelRunning,    int32_t,  RET_int32_t)" + NL + "SVC_0_1(svcKernelSysTick,    uint32_t, RET_uint32_t)" + NL + "" + NL + "static void  sysThreadError   (osStatus status);" + NL + "osThreadId   svcThreadCreate  (const osThreadDef_t *thread_def, void *argument);" + NL + "osMessageQId svcMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id);" + NL + "" + NL + "// Kernel Control Service Calls" + NL + "" + NL + "/// Initialize the RTOS Kernel for creating objects" + NL + "osStatus svcKernelInitialize (void) {" + NL + "  int ret;" + NL + "" + NL + "  if (!os_initialized) {" + NL + "" + NL + "    // Init Thread Stack Memory (must be 8-byte aligned)" + NL + "    if ((uint32_t)os_stack_mem & 7) return osErrorNoMemory;" + NL + "    ret = rt_init_mem(os_stack_mem, os_stack_sz);" + NL + "    if (ret != 0) return osErrorNoMemory;" + NL + "" + NL + "    rt_sys_init();                              // RTX System Initialization" + NL + "  }" + NL + "" + NL + "  os_tsk.run->prio = 255;                       // Highest priority" + NL + "" + NL + "  if (!os_initialized) {" + NL + "    // Create OS Timers resources (Message Queue & Thread)" + NL + "    osMessageQId_osTimerMessageQ = svcMessageCreate (&os_messageQ_def_osTimerMessageQ, NULL);" + NL + "    osThreadId_osTimerThread = svcThreadCreate(&os_thread_def_osTimerThread, NULL);" + NL + "  }" + NL + "" + NL + "  sysThreadError(osOK);" + NL + "" + NL + "  os_initialized = 1;" + NL + "  os_running = 0;" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "/// Start the RTOS Kernel" + NL + "osStatus svcKernelStart (void) {" + NL + "" + NL + "  if (os_running) return osOK;" + NL + "" + NL + "  rt_tsk_prio(0, os_tsk.run->prio_base);        // Restore priority" + NL + "  if (os_tsk.run->task_id == 0xFF) {            // Idle Thread" + NL + "    __set_PSP(os_tsk.run->tsk_stack + 8*4);     // Setup PSP" + NL + "  }" + NL + "  if (os_tsk.new == NULL) {                     // Force context switch" + NL + "    os_tsk.new = os_tsk.run;" + NL + "    os_tsk.run = NULL;" + NL + "  }" + NL + "" + NL + "  rt_sys_start();" + NL + "" + NL + "  os_running = 1;" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "/// Check if the RTOS kernel is already started" + NL + "int32_t svcKernelRunning (void) {" + NL + "  return os_running;" + NL + "}" + NL + "" + NL + "/// Get the RTOS kernel system timer counter" + NL + "uint32_t svcKernelSysTick (void) {" + NL + "  uint32_t tick, tick0;" + NL + "" + NL + "  tick = os_tick_val();" + NL + "  if (os_tick_ovf()) {" + NL + "    tick0 = os_tick_val();" + NL + "    if (tick0 < tick) tick = tick0;" + NL + "    tick += (os_trv + 1) * (os_time + 1);" + NL + "  } else {" + NL + "    tick += (os_trv + 1) *  os_time;" + NL + "  }" + NL + "" + NL + "  return tick;" + NL + "}" + NL + "" + NL + "// Kernel Control Public API" + NL + "" + NL + "/// Initialize the RTOS Kernel for creating objects" + NL + "osStatus osKernelInitialize (void) {" + NL + "  if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR" + NL + "  if ((__get_CONTROL() & 1) == 0) {             // Privileged mode" + NL + "    return   svcKernelInitialize();" + NL + "  } else {" + NL + "    return __svcKernelInitialize();" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Start the RTOS Kernel" + NL + "osStatus osKernelStart (void) {" + NL + "  uint32_t stack[8];" + NL + "" + NL + "  if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR" + NL + "  switch (__get_CONTROL() & 0x03) {" + NL + "    case 0x00:                                  // Privileged Thread mode & MSP" + NL + "      __set_PSP((uint32_t)(stack + 8));         // Initial PSP" + NL + "      if (os_flags & 1) {                       " + NL + "        __set_CONTROL(0x02);                    // Set Privileged Thread mode & PSP" + NL + "      } else {" + NL + "        __set_CONTROL(0x03);                    // Set Unprivileged Thread mode & PSP" + NL + "      }" + NL + "      __DSB();" + NL + "      __ISB();" + NL + "      break;" + NL + "    case 0x01:                                  // Unprivileged Thread mode & MSP" + NL + "      return osErrorOS;" + NL + "    case 0x02:                                  // Privileged Thread mode & PSP" + NL + "      if ((os_flags & 1) == 0) {                // Unprivileged Thread mode requested" + NL + "        __set_CONTROL(0x03);                    // Set Unprivileged Thread mode & PSP" + NL + "        __DSB();" + NL + "        __ISB();" + NL + "      }" + NL + "      break;" + NL + "    case 0x03:                                  // Unprivileged Thread mode & PSP" + NL + "      if  (os_flags & 1) return osErrorOS;      // Privileged Thread mode requested" + NL + "      break;" + NL + "  }" + NL + "  return __svcKernelStart();" + NL + "}" + NL + "" + NL + "/// Check if the RTOS kernel is already started" + NL + "int32_t osKernelRunning (void) {" + NL + "  if ((__get_IPSR() != 0) || ((__get_CONTROL() & 1) == 0)) {" + NL + "    // in ISR or Privileged" + NL + "    return os_running;" + NL + "  } else {" + NL + "    return __svcKernelRunning();" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Get the RTOS kernel system timer counter" + NL + "uint32_t osKernelSysTick (void) {" + NL + "  if (__get_IPSR() != 0) return 0;              // Not allowed in ISR" + NL + "  return __svcKernelSysTick();" + NL + "}" + NL + "" + NL + "" + NL + "// ==== Thread Management ====" + NL + "" + NL + "/// Set Thread Error (for Create functions which return IDs)" + NL + "static void sysThreadError (osStatus status) {" + NL + "  // To Do" + NL + "}" + NL + "" + NL + "__NO_RETURN void osThreadExit (void);" + NL + "" + NL + "// Thread Service Calls declarations" + NL + "SVC_2_1(svcThreadCreate,      osThreadId, const osThreadDef_t *, void *,     RET_pointer)" + NL + "SVC_0_1(svcThreadGetId,       osThreadId,                                    RET_pointer)" + NL + "SVC_1_1(svcThreadTerminate,   osStatus,         osThreadId,                  RET_osStatus)" + NL + "SVC_0_1(svcThreadYield,       osStatus,                                      RET_osStatus)" + NL + "SVC_2_1(svcThreadSetPriority, osStatus,         osThreadId,      osPriority, RET_osStatus)" + NL + "SVC_1_1(svcThreadGetPriority, osPriority,       osThreadId,                  RET_osPriority)" + NL + "" + NL + "// Thread Service Calls" + NL + "" + NL + "/// Create a thread and add it to Active Threads and set it to state READY" + NL + "osThreadId svcThreadCreate (const osThreadDef_t *thread_def, void *argument) {" + NL + "  P_TCB  ptcb;" + NL + "  OS_TID tsk;" + NL + "  void  *stk;" + NL + "" + NL + "  if ((thread_def == NULL) ||" + NL + "      (thread_def->pthread == NULL) ||" + NL + "      (thread_def->tpriority < osPriorityIdle) ||" + NL + "      (thread_def->tpriority > osPriorityRealtime)) {" + NL + "    sysThreadError(osErrorParameter); " + NL + "    return NULL; " + NL + "  }" + NL + "" + NL + "  if (thread_def->stacksize != 0) {             // Custom stack size" + NL + "    stk = rt_alloc_mem(                         // Allocate stack" + NL + "      os_stack_mem," + NL + "      thread_def->stacksize" + NL + "    );" + NL + "    if (stk == NULL) { " + NL + "      sysThreadError(osErrorNoMemory);          // Out of memory" + NL + "      return NULL;" + NL + "    }" + NL + "  } else {                                      // Default stack size" + NL + "    stk = NULL;" + NL + "  }" + NL + "" + NL + "  tsk = rt_tsk_create(                          // Create task" + NL + "    (FUNCP)thread_def->pthread,                 // Task function pointer" + NL + "    (thread_def->tpriority-osPriorityIdle+1) |  // Task priority" + NL + "    (thread_def->stacksize << 8),               // Task stack size in bytes" + NL + "    stk,                                        // Pointer to task's stack" + NL + "    argument                                    // Argument to the task" + NL + "  );" + NL + "" + NL + "  if (tsk == 0) {                               // Invalid task ID" + NL + "    if (stk != NULL) {" + NL + "      rt_free_mem(os_stack_mem, stk);           // Free allocated stack" + NL + "    }" + NL + "    sysThreadError(osErrorNoMemory);            // Create task failed (Out of memory)" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  ptcb = (P_TCB)os_active_TCB[tsk - 1];         // TCB pointer" + NL + "" + NL + "  *((uint32_t *)ptcb->tsk_stack + 13) = (uint32_t)osThreadExit;" + NL + "" + NL + "  return ptcb;" + NL + "}" + NL + "" + NL + "/// Return the thread ID of the current running thread" + NL + "osThreadId svcThreadGetId (void) {" + NL + "  OS_TID tsk;" + NL + "" + NL + "  tsk = rt_tsk_self();" + NL + "  if (tsk == 0) return NULL;" + NL + "  return (P_TCB)os_active_TCB[tsk - 1];" + NL + "}" + NL + "" + NL + "/// Terminate execution of a thread and remove it from ActiveThreads" + NL + "osStatus svcThreadTerminate (osThreadId thread_id) {" + NL + "  OS_RESULT res;" + NL + "  P_TCB     ptcb;" + NL + "  void     *stk;" + NL + "" + NL + "  ptcb = rt_tid2ptcb(thread_id);                // Get TCB pointer" + NL + "  if (ptcb == NULL) return osErrorParameter;" + NL + "" + NL + "  stk = ptcb->priv_stack ? ptcb->stack : NULL;  // Private stack" + NL + "" + NL + "  res = rt_tsk_delete(ptcb->task_id);           // Delete task" + NL + "" + NL + "  if (res == OS_R_NOK) return osErrorResource;  // Delete task failed" + NL + "" + NL + "  if (stk != NULL) {                            " + NL + "    rt_free_mem(os_stack_mem, stk);             // Free private stack" + NL + "  }" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "/// Pass control to next thread that is in state READY" + NL + "osStatus svcThreadYield (void) {" + NL + "  rt_tsk_pass();                                // Pass control to next task" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "/// Change priority of an active thread" + NL + "osStatus svcThreadSetPriority (osThreadId thread_id, osPriority priority) {" + NL + "  OS_RESULT res;" + NL + "  P_TCB     ptcb;" + NL + "" + NL + "  ptcb = rt_tid2ptcb(thread_id);                // Get TCB pointer" + NL + "  if (ptcb == NULL) return osErrorParameter;" + NL + "" + NL + "  if ((priority < osPriorityIdle) || (priority > osPriorityRealtime)) {" + NL + "    return osErrorValue;" + NL + "  }" + NL + "" + NL + "  res = rt_tsk_prio(                            // Change task priority" + NL + "    ptcb->task_id,                              // Task ID" + NL + "    priority - osPriorityIdle + 1               // New task priority" + NL + "  );" + NL + "" + NL + "  if (res == OS_R_NOK) return osErrorResource;  // Change task priority failed" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "/// Get current priority of an active thread" + NL + "osPriority svcThreadGetPriority (osThreadId thread_id) {" + NL + "  P_TCB ptcb;" + NL + "" + NL + "  ptcb = rt_tid2ptcb(thread_id);                // Get TCB pointer" + NL + "  if (ptcb == NULL) return osPriorityError;" + NL + "" + NL + "  return (osPriority)(ptcb->prio - 1 + osPriorityIdle); " + NL + "}" + NL + "" + NL + "" + NL + "// Thread Public API" + NL + "" + NL + "/// Create a thread and add it to Active Threads and set it to state READY" + NL + "osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument) {" + NL + "  if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR" + NL + "  if (((__get_CONTROL() & 1) == 0) && (os_running == 0)) {" + NL + "    // Privileged and not running" + NL + "    return   svcThreadCreate(thread_def, argument);" + NL + "  } else {" + NL + "    return __svcThreadCreate(thread_def, argument);" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Return the thread ID of the current running thread" + NL + "osThreadId osThreadGetId (void) {" + NL + "  if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR" + NL + "  return __svcThreadGetId();" + NL + "}" + NL + "" + NL + "/// Terminate execution of a thread and remove it from ActiveThreads" + NL + "osStatus osThreadTerminate (osThreadId thread_id) {" + NL + "  if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR" + NL + "  return __svcThreadTerminate(thread_id);" + NL + "}" + NL + "" + NL + "/// Pass control to next thread that is in state READY" + NL + "osStatus osThreadYield (void) {" + NL + "  if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR" + NL + "  return __svcThreadYield();" + NL + "}" + NL + "" + NL + "/// Change priority of an active thread" + NL + "osStatus osThreadSetPriority (osThreadId thread_id, osPriority priority) {" + NL + "  if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR" + NL + "  return __svcThreadSetPriority(thread_id, priority);" + NL + "}" + NL + "" + NL + "/// Get current priority of an active thread" + NL + "osPriority osThreadGetPriority (osThreadId thread_id) {" + NL + "  if (__get_IPSR() != 0) return osPriorityError;// Not allowed in ISR" + NL + "  return __svcThreadGetPriority(thread_id);" + NL + "}" + NL + "" + NL + "/// INTERNAL - Not Public" + NL + "/// Auto Terminate Thread on exit (used implicitly when thread exists)" + NL + "__NO_RETURN void osThreadExit (void) { " + NL + "  __svcThreadTerminate(__svcThreadGetId()); " + NL + "  for (;;);                                     // Should never come here" + NL + "}" + NL + "" + NL + "" + NL + "// ==== Generic Wait Functions ====" + NL + "" + NL + "// Generic Wait Service Calls declarations" + NL + "SVC_1_1(svcDelay,           osStatus, uint32_t, RET_osStatus)" + NL + "#if osFeature_Wait != 0" + NL + "SVC_1_3(svcWait,  os_InRegs osEvent,  uint32_t, RET_osEvent)" + NL + "#endif" + NL + "" + NL + "// Generic Wait Service Calls" + NL + "" + NL + "/// Wait for Timeout (Time Delay)" + NL + "osStatus svcDelay (uint32_t millisec) {" + NL + "  if (millisec == 0) return osOK;" + NL + "  rt_dly_wait(rt_ms2tick(millisec));" + NL + "  return osEventTimeout;" + NL + "}" + NL + "" + NL + "/// Wait for Signal, Message, Mail, or Timeout" + NL + "#if osFeature_Wait != 0" + NL + "os_InRegs osEvent_type svcWait (uint32_t millisec) {" + NL + "  osEvent ret;" + NL + "" + NL + "  if (millisec == 0) {" + NL + "    ret.status = osOK;" + NL + "    return osEvent_ret_status;" + NL + "  }" + NL + "" + NL + "  /* To Do: osEventSignal, osEventMessage, osEventMail */" + NL + "  rt_dly_wait(rt_ms2tick(millisec));" + NL + "  ret.status = osEventTimeout;" + NL + NL;
  protected final String TEXT_6 = "  return osEvent_ret_status;" + NL + "}" + NL + "#endif" + NL + "" + NL + "" + NL + "// Generic Wait API" + NL + "" + NL + "/// Wait for Timeout (Time Delay)" + NL + "osStatus osDelay (uint32_t millisec) {" + NL + "  if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR" + NL + "  return __svcDelay(millisec);" + NL + "}" + NL + "" + NL + "/// Wait for Signal, Message, Mail, or Timeout" + NL + "os_InRegs osEvent osWait (uint32_t millisec) {" + NL + "  osEvent ret;" + NL + "" + NL + "#if osFeature_Wait == 0" + NL + "  ret.status = osErrorOS;" + NL + "  return ret;" + NL + "#else" + NL + "  if (__get_IPSR() != 0) {                      // Not allowed in ISR" + NL + "    ret.status = osErrorISR;" + NL + "    return ret;" + NL + "  }" + NL + "  return __svcWait(millisec);" + NL + "#endif" + NL + "}" + NL + "" + NL + "" + NL + "// ==== Timer Management ====" + NL + "" + NL + "// Timer definitions" + NL + "#define osTimerInvalid  0" + NL + "#define osTimerStopped  1" + NL + "#define osTimerRunning  2" + NL + "" + NL + "// Timer structures " + NL + "" + NL + "typedef struct os_timer_cb_ {                   // Timer Control Block" + NL + "  struct os_timer_cb_ *next;                    // Pointer to next active Timer" + NL + "  uint8_t             state;                    // Timer State" + NL + "  uint8_t              type;                    // Timer Type (Periodic/One-shot)" + NL + "  uint16_t         reserved;                    // Reserved" + NL + "  uint16_t             tcnt;                    // Timer Delay Count" + NL + "  uint16_t             icnt;                    // Timer Initial Count " + NL + "  void                 *arg;                    // Timer Function Argument" + NL + "  const osTimerDef_t *timer;                    // Pointer to Timer definition" + NL + "} os_timer_cb;" + NL + "" + NL + "// Timer variables" + NL + "os_timer_cb *os_timer_head;                     // Pointer to first active Timer" + NL + "" + NL + "" + NL + "// Timer Helper Functions" + NL + "" + NL + "// Insert Timer into the list sorted by time" + NL + "static void rt_timer_insert (os_timer_cb *pt, uint32_t tcnt) {" + NL + "  os_timer_cb *p, *prev;" + NL + "" + NL + "  prev = NULL;" + NL + "  p = os_timer_head;" + NL + "  while (p != NULL) {" + NL + "    if (tcnt < p->tcnt) break;" + NL + "    tcnt -= p->tcnt;" + NL + "    prev = p;" + NL + "    p = p->next;" + NL + "  }" + NL + "  pt->next = p;" + NL + "  pt->tcnt = (uint16_t)tcnt;" + NL + "  if (p != NULL) {" + NL + "    p->tcnt -= pt->tcnt;" + NL + "  }" + NL + "  if (prev != NULL) {" + NL + "    prev->next = pt;" + NL + "  } else {" + NL + "    os_timer_head = pt;" + NL + "  }" + NL + "}" + NL + "" + NL + "// Remove Timer from the list" + NL + "static int rt_timer_remove (os_timer_cb *pt) {" + NL + "  os_timer_cb *p, *prev;" + NL + "" + NL + "  prev = NULL;" + NL + "  p = os_timer_head;" + NL + "  while (p != NULL) {" + NL + "    if (p == pt) break;" + NL + "    prev = p;" + NL + "    p = p->next;" + NL + "  }" + NL + "  if (p == NULL) return -1;" + NL + "  if (prev != NULL) {" + NL + "    prev->next = pt->next;" + NL + "  } else {" + NL + "    os_timer_head = pt->next;" + NL + "  }" + NL + "  if (pt->next != NULL) {" + NL + "    pt->next->tcnt += pt->tcnt;" + NL + "  }" + NL + "" + NL + "  return 0;" + NL + "}" + NL + "" + NL + "" + NL + "// Timer Service Calls declarations" + NL + "SVC_3_1(svcTimerCreate,           osTimerId,  const osTimerDef_t *, os_timer_type, void *, RET_pointer)" + NL + "SVC_2_1(svcTimerStart,            osStatus,         osTimerId,      uint32_t,              RET_osStatus)" + NL + "SVC_1_1(svcTimerStop,             osStatus,         osTimerId,                             RET_osStatus)" + NL + "SVC_1_1(svcTimerDelete,           osStatus,         osTimerId,                             RET_osStatus)" + NL + "SVC_1_2(svcTimerCall,   os_InRegs osCallback,       osTimerId,                             RET_osCallback)" + NL + "" + NL + "// Timer Management Service Calls" + NL + "" + NL + "/// Create timer" + NL + "osTimerId svcTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument) {" + NL + "  os_timer_cb *pt;" + NL + "" + NL + "  if ((timer_def == NULL) || (timer_def->ptimer == NULL)) {" + NL + "    sysThreadError(osErrorParameter);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  pt = timer_def->timer;" + NL + "  if (pt == NULL) {" + NL + "    sysThreadError(osErrorParameter);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  if ((type != osTimerOnce) && (type != osTimerPeriodic)) {" + NL + "    sysThreadError(osErrorValue);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  if (osThreadId_osTimerThread == NULL) {" + NL + "    sysThreadError(osErrorResource);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  if (pt->state != osTimerInvalid){" + NL + "    sysThreadError(osErrorResource);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  pt->next  = NULL;" + NL + "  pt->state = osTimerStopped;" + NL + "  pt->type  =  (uint8_t)type;" + NL + "  pt->arg   = argument;" + NL + "  pt->timer = timer_def;" + NL + "" + NL + "  return (osTimerId)pt;" + NL + "}" + NL + "" + NL + "/// Start or restart timer" + NL + "osStatus svcTimerStart (osTimerId timer_id, uint32_t millisec) {" + NL + "  os_timer_cb *pt;" + NL + "  uint32_t     tcnt;" + NL + "" + NL + "  pt = rt_id2obj(timer_id);" + NL + "  if (pt == NULL) return osErrorParameter;" + NL + "" + NL + "  tcnt = rt_ms2tick(millisec);" + NL + "  if (tcnt == 0) return osErrorValue;" + NL + "" + NL + "  switch (pt->state) {" + NL + "    case osTimerRunning:" + NL + "      if (rt_timer_remove(pt) != 0) {" + NL + "        return osErrorResource;" + NL + "      }" + NL + "      break;" + NL + "    case osTimerStopped:" + NL + "      pt->state = osTimerRunning;" + NL + "      pt->icnt  = (uint16_t)tcnt;" + NL + "      break;" + NL + "    default:" + NL + "      return osErrorResource;" + NL + "  }" + NL + "  " + NL + "  rt_timer_insert(pt, tcnt);" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "/// Stop timer" + NL + "osStatus svcTimerStop (osTimerId timer_id) {" + NL + "  os_timer_cb *pt;" + NL + "" + NL + "  pt = rt_id2obj(timer_id);" + NL + "  if (pt == NULL) return osErrorParameter;" + NL + "" + NL + "  if (pt->state != osTimerRunning) return osErrorResource;" + NL + "" + NL + "  pt->state = osTimerStopped;" + NL + "" + NL + "  if (rt_timer_remove(pt) != 0) {" + NL + "    return osErrorResource;" + NL + "  }" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "/// Delete timer" + NL + "osStatus svcTimerDelete (osTimerId timer_id) {" + NL + "  os_timer_cb *pt;" + NL + "" + NL + "  pt = rt_id2obj(timer_id);" + NL + "  if (pt == NULL) return osErrorParameter;" + NL + "" + NL + "  switch (pt->state) {" + NL + "    case osTimerRunning:" + NL + "      rt_timer_remove(pt);" + NL + "      break;" + NL + "    case osTimerStopped:" + NL + "      break;" + NL + "    default:" + NL + "      return osErrorResource;" + NL + "  }" + NL + "" + NL + "  pt->state = osTimerInvalid;" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "/// Get timer callback parameters" + NL + "os_InRegs osCallback_type svcTimerCall (osTimerId timer_id) {" + NL + "  os_timer_cb *pt;" + NL + "  osCallback   ret;" + NL + "" + NL + "  pt = rt_id2obj(timer_id);" + NL + "  if (pt == NULL) {" + NL + "    ret.fp  = NULL;" + NL + "    ret.arg = NULL;" + NL + "    return osCallback_ret;" + NL + "  }" + NL + "" + NL + "  ret.fp  = (void *)pt->timer->ptimer;" + NL + "  ret.arg = pt->arg;" + NL + "" + NL + "  return osCallback_ret;" + NL + "}" + NL + "" + NL + "static __INLINE osStatus isrMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec);" + NL + "" + NL + "/// Timer Tick (called each SysTick)" + NL + "void sysTimerTick (void) {" + NL + "  os_timer_cb *pt, *p;" + NL + "" + NL + "  p = os_timer_head;" + NL + "  if (p == NULL) return;" + NL + "" + NL + "  p->tcnt--;" + NL + "  while ((p != NULL) && (p->tcnt == 0)) {" + NL + "    pt = p;" + NL + "    p = p->next;" + NL + "    os_timer_head = p;" + NL + "    isrMessagePut(osMessageQId_osTimerMessageQ, (uint32_t)pt, 0);" + NL + "    if (pt->type == osTimerPeriodic) {" + NL + "      rt_timer_insert(pt, pt->icnt);" + NL + "    } else {" + NL + "      pt->state = osTimerStopped;" + NL + "    }" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Get user timers wake-up time " + NL + "uint32_t sysUserTimerWakeupTime (void) {" + NL + "" + NL + "  if (os_timer_head) {" + NL + "    return os_timer_head->tcnt;" + NL + "  }" + NL + "  return 0xFFFF;" + NL + "}" + NL + "" + NL + "/// Update user timers on resume" + NL + "void sysUserTimerUpdate (uint32_t sleep_time) {" + NL + "" + NL + "  while (os_timer_head && sleep_time) {" + NL + "    if (sleep_time >= os_timer_head->tcnt) {" + NL + "      sleep_time -= os_timer_head->tcnt;" + NL + "      os_timer_head->tcnt = 1;" + NL + "      sysTimerTick();" + NL + "    } else {" + NL + "      os_timer_head->tcnt -= sleep_time;" + NL + "      break;" + NL + "    }" + NL + "  }" + NL + "}" + NL + "" + NL + "" + NL + "// Timer Management Public API" + NL + "" + NL + "/// Create timer" + NL + "osTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument) {" + NL + "  if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR" + NL + "  if (((__get_CONTROL() & 1) == 0) && (os_running == 0)) {" + NL + "    // Privileged and not running" + NL + "    return   svcTimerCreate(timer_def, type, argument);" + NL + "  } else {" + NL + "    return __svcTimerCreate(timer_def, type, argument);" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Start or restart timer" + NL + "osStatus osTimerStart (osTimerId timer_id, uint32_t millisec) {" + NL + "  if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR" + NL + "  return __svcTimerStart(timer_id, millisec);" + NL + "}" + NL + "" + NL + "/// Stop timer" + NL + "osStatus osTimerStop (osTimerId timer_id) {" + NL + "  if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR" + NL + "  return __svcTimerStop(timer_id);" + NL + "}" + NL + "" + NL + "/// Delete timer" + NL + "osStatus osTimerDelete (osTimerId timer_id) {" + NL + "  if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR" + NL + "  return __svcTimerDelete(timer_id);" + NL + "}" + NL + "" + NL + "/// INTERNAL - Not Public" + NL + "/// Get timer callback parameters (used by OS Timer Thread)" + NL + "os_InRegs osCallback osTimerCall (osTimerId timer_id) { " + NL + "  return __svcTimerCall(timer_id); " + NL + "}" + NL + "" + NL + "" + NL + "// Timer Thread" + NL + "__NO_RETURN void osTimerThread (void const *argument) {" + NL + "  osCallback cb;" + NL + "  osEvent    evt;" + NL + "" + NL + "  for (;;) {" + NL + "    evt = osMessageGet(osMessageQId_osTimerMessageQ, osWaitForever);" + NL + "    if (evt.status == osEventMessage) {" + NL + "      cb = osTimerCall(evt.value.p);" + NL + "      if (cb.fp != NULL) {" + NL + "        (*(os_ptimer)cb.fp)(cb.arg);" + NL + "      }" + NL + "    }" + NL + "  }" + NL + "}" + NL + "" + NL + "" + NL + "// ==== Signal Management ====" + NL + "" + NL + "// Signal Service Calls declarations" + NL + "SVC_2_1(svcSignalSet,             int32_t, osThreadId, int32_t,  RET_int32_t)" + NL + "SVC_2_1(svcSignalClear,           int32_t, osThreadId, int32_t,  RET_int32_t)" + NL + "SVC_2_3(svcSignalWait,  os_InRegs osEvent, int32_t,    uint32_t, RET_osEvent)" + NL + "" + NL + "// Signal Service Calls" + NL + "" + NL + "/// Set the specified Signal Flags of an active thread" + NL + "int32_t svcSignalSet (osThreadId thread_id, int32_t signals) {" + NL + "  P_TCB   ptcb;" + NL + "  int32_t sig;" + NL + "" + NL + "  ptcb = rt_tid2ptcb(thread_id);                // Get TCB pointer" + NL + "  if (ptcb == NULL) return 0x80000000;" + NL + "" + NL + "  if (signals & (0xFFFFFFFF << osFeature_Signals)) return 0x80000000;" + NL + "" + NL + "  sig = ptcb->events;                           // Previous signal flags" + NL + "" + NL + "  rt_evt_set(signals, ptcb->task_id);           // Set event flags" + NL + "" + NL + "  return sig;" + NL + "}" + NL + "" + NL + "/// Clear the specified Signal Flags of an active thread" + NL + "int32_t svcSignalClear (osThreadId thread_id, int32_t signals) {" + NL + "  P_TCB   ptcb;" + NL + "  int32_t sig;" + NL + "" + NL + "  ptcb = rt_tid2ptcb(thread_id);                // Get TCB pointer" + NL + "  if (ptcb == NULL) return 0x80000000;" + NL + "" + NL + "  if (signals & (0xFFFFFFFF << osFeature_Signals)) return 0x80000000;" + NL + "" + NL + "  sig = ptcb->events;                           // Previous signal flags" + NL + "" + NL + "  rt_evt_clr(signals, ptcb->task_id);           // Clear event flags" + NL + "" + NL + "  return sig;" + NL + "}" + NL + "" + NL + "/// Wait for one or more Signal Flags to become signaled for the current RUNNING thread" + NL + "os_InRegs osEvent_type svcSignalWait (int32_t signals, uint32_t millisec) {" + NL + "  OS_RESULT res;" + NL + "  osEvent   ret;" + NL + "" + NL + "  if (signals & (0xFFFFFFFF << osFeature_Signals)) {" + NL + "    ret.status = osErrorValue;" + NL + "    return osEvent_ret_status;" + NL + "  }" + NL + "" + NL + "  if (signals != 0) {                           // Wait for all specified signals" + NL + "    res = rt_evt_wait(signals, rt_ms2tick(millisec), __TRUE);" + NL + "  } else {                                      // Wait for any signal" + NL + "    res = rt_evt_wait(0xFFFF,  rt_ms2tick(millisec), __FALSE);" + NL;
  protected final String TEXT_7 = "  }" + NL + "" + NL + "  if (res == OS_R_EVT) {" + NL + "    ret.status = osEventSignal;" + NL + "    ret.value.signals = signals ? signals : os_tsk.run->waits;" + NL + "  } else {" + NL + "    ret.status = millisec ? osEventTimeout : osOK;" + NL + "    ret.value.signals = 0;" + NL + "  }" + NL + "" + NL + "  return osEvent_ret_value;" + NL + "}" + NL + "" + NL + "" + NL + "// Signal ISR Calls" + NL + "" + NL + "/// Set the specified Signal Flags of an active thread" + NL + "static __INLINE int32_t isrSignalSet (osThreadId thread_id, int32_t signals) {" + NL + "  P_TCB   ptcb;" + NL + "  int32_t sig;" + NL + "" + NL + "  ptcb = rt_tid2ptcb(thread_id);                // Get TCB pointer" + NL + "  if (ptcb == NULL) return 0x80000000;" + NL + "" + NL + "  if (signals & (0xFFFFFFFF << osFeature_Signals)) return 0x80000000;" + NL + "" + NL + "  sig = ptcb->events;                           // Previous signal flags" + NL + "" + NL + "  isr_evt_set(signals, ptcb->task_id);          // Set event flags" + NL + "" + NL + "  return sig;" + NL + "}" + NL + "" + NL + "" + NL + "// Signal Public API" + NL + "" + NL + "/// Set the specified Signal Flags of an active thread" + NL + "int32_t osSignalSet (osThreadId thread_id, int32_t signals) {" + NL + "  if (__get_IPSR() != 0) {                      // in ISR" + NL + "    return   isrSignalSet(thread_id, signals); " + NL + "  } else {                                      // in Thread" + NL + "    return __svcSignalSet(thread_id, signals);" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Clear the specified Signal Flags of an active thread" + NL + "int32_t osSignalClear (osThreadId thread_id, int32_t signals) {" + NL + "  if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR" + NL + "  return __svcSignalClear(thread_id, signals);" + NL + "}" + NL + "" + NL + "/// Wait for one or more Signal Flags to become signaled for the current RUNNING thread" + NL + "os_InRegs osEvent osSignalWait (int32_t signals, uint32_t millisec) {" + NL + "  osEvent ret;" + NL + "" + NL + "  if (__get_IPSR() != 0) {                      // Not allowed in ISR" + NL + "    ret.status = osErrorISR;" + NL + "    return ret;" + NL + "  }" + NL + "  return __svcSignalWait(signals, millisec);" + NL + "}" + NL + "" + NL + "" + NL + "// ==== Mutex Management ====" + NL + "" + NL + "// Mutex Service Calls declarations" + NL + "SVC_1_1(svcMutexCreate,  osMutexId, const osMutexDef_t *,           RET_pointer)" + NL + "SVC_2_1(svcMutexWait,    osStatus,        osMutexId,      uint32_t, RET_osStatus)" + NL + "SVC_1_1(svcMutexRelease, osStatus,        osMutexId,                RET_osStatus)" + NL + "SVC_1_1(svcMutexDelete,  osStatus,        osMutexId,                RET_osStatus)" + NL + "" + NL + "// Mutex Service Calls" + NL + "" + NL + "/// Create and Initialize a Mutex object" + NL + "osMutexId svcMutexCreate (const osMutexDef_t *mutex_def) {" + NL + "  OS_ID mut;" + NL + "" + NL + "  if (mutex_def == NULL) {" + NL + "    sysThreadError(osErrorParameter);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  mut = mutex_def->mutex;" + NL + "  if (mut == NULL) {" + NL + "    sysThreadError(osErrorParameter);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  if (((P_MUCB)mut)->cb_type != 0) {" + NL + "    sysThreadError(osErrorParameter);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  rt_mut_init(mut);                             // Initialize Mutex" + NL + "" + NL + "  return mut;" + NL + "}" + NL + "" + NL + "/// Wait until a Mutex becomes available" + NL + "osStatus svcMutexWait (osMutexId mutex_id, uint32_t millisec) {" + NL + "  OS_ID     mut;" + NL + "  OS_RESULT res;" + NL + "" + NL + "  mut = rt_id2obj(mutex_id);" + NL + "  if (mut == NULL) return osErrorParameter;" + NL + "" + NL + "  if (((P_MUCB)mut)->cb_type != MUCB) return osErrorParameter;" + NL + "" + NL + "  res = rt_mut_wait(mut, rt_ms2tick(millisec)); // Wait for Mutex" + NL + "" + NL + "  if (res == OS_R_TMO) {" + NL + "    return (millisec ? osErrorTimeoutResource : osErrorResource);" + NL + "  }" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "/// Release a Mutex that was obtained with osMutexWait" + NL + "osStatus svcMutexRelease (osMutexId mutex_id) {" + NL + "  OS_ID     mut;" + NL + "  OS_RESULT res;" + NL + "" + NL + "  mut = rt_id2obj(mutex_id);" + NL + "  if (mut == NULL) return osErrorParameter;" + NL + "" + NL + "  if (((P_MUCB)mut)->cb_type != MUCB) return osErrorParameter;" + NL + "" + NL + "  res = rt_mut_release(mut);                    // Release Mutex" + NL + "" + NL + "  if (res == OS_R_NOK) return osErrorResource;  // Thread not owner or Zero Counter" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "/// Delete a Mutex that was created by osMutexCreate" + NL + "osStatus svcMutexDelete (osMutexId mutex_id) {" + NL + "  OS_ID mut;" + NL + "" + NL + "  mut = rt_id2obj(mutex_id);" + NL + "  if (mut == NULL) return osErrorParameter;" + NL + "" + NL + "  if (((P_MUCB)mut)->cb_type != MUCB) return osErrorParameter;" + NL + "" + NL + "  rt_mut_delete(mut);                           // Release Mutex" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "" + NL + "// Mutex Public API" + NL + "" + NL + "/// Create and Initialize a Mutex object" + NL + "osMutexId osMutexCreate (const osMutexDef_t *mutex_def) {" + NL + "  if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR" + NL + "  if (((__get_CONTROL() & 1) == 0) && (os_running == 0)) {" + NL + "    // Privileged and not running" + NL + "    return    svcMutexCreate(mutex_def);" + NL + "  } else {" + NL + "    return __svcMutexCreate(mutex_def);" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Wait until a Mutex becomes available" + NL + "osStatus osMutexWait (osMutexId mutex_id, uint32_t millisec) {" + NL + "  if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR" + NL + "  return __svcMutexWait(mutex_id, millisec);" + NL + "}" + NL + "" + NL + "/// Release a Mutex that was obtained with osMutexWait" + NL + "osStatus osMutexRelease (osMutexId mutex_id) {" + NL + "  if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR" + NL + "  return __svcMutexRelease(mutex_id);" + NL + "}" + NL + "" + NL + "/// Delete a Mutex that was created by osMutexCreate" + NL + "osStatus osMutexDelete (osMutexId mutex_id) {" + NL + "  if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR" + NL + "  return __svcMutexDelete(mutex_id);" + NL + "}" + NL + "" + NL + "" + NL + "// ==== Semaphore Management ====" + NL + "" + NL + "// Semaphore Service Calls declarations" + NL + "SVC_2_1(svcSemaphoreCreate,  osSemaphoreId, const osSemaphoreDef_t *,  int32_t, RET_pointer)" + NL + "SVC_2_1(svcSemaphoreWait,    int32_t,             osSemaphoreId,      uint32_t, RET_int32_t)" + NL + "SVC_1_1(svcSemaphoreRelease, osStatus,            osSemaphoreId,                RET_osStatus)" + NL + "SVC_1_1(svcSemaphoreDelete,  osStatus,            osSemaphoreId,                RET_osStatus)" + NL + "" + NL + "// Semaphore Service Calls" + NL + "" + NL + "/// Create and Initialize a Semaphore object" + NL + "osSemaphoreId svcSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count) {" + NL + "  OS_ID sem;" + NL + "" + NL + "  if (semaphore_def == NULL) {" + NL + "    sysThreadError(osErrorParameter);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  sem = semaphore_def->semaphore;" + NL + "  if (sem == NULL) {" + NL + "    sysThreadError(osErrorParameter);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  if (((P_SCB)sem)->cb_type != 0) {" + NL + "    sysThreadError(osErrorParameter);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  if (count > osFeature_Semaphore) {" + NL + "    sysThreadError(osErrorValue);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  rt_sem_init(sem, count);                      // Initialize Semaphore" + NL + "  " + NL + "  return sem;" + NL + "}" + NL + "" + NL + "/// Wait until a Semaphore becomes available" + NL + "int32_t svcSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec) {" + NL + "  OS_ID     sem;" + NL + "  OS_RESULT res;" + NL + "" + NL + "  sem = rt_id2obj(semaphore_id);" + NL + "  if (sem == NULL) return -1;" + NL + "" + NL + "  if (((P_SCB)sem)->cb_type != SCB) return -1;" + NL + "" + NL + "  res = rt_sem_wait(sem, rt_ms2tick(millisec)); // Wait for Semaphore" + NL + "" + NL + "  if (res == OS_R_TMO) return 0;                // Timeout" + NL + "" + NL + "  return (((P_SCB)sem)->tokens + 1);" + NL + "}" + NL + "" + NL + "/// Release a Semaphore" + NL + "osStatus svcSemaphoreRelease (osSemaphoreId semaphore_id) {" + NL + "  OS_ID sem;" + NL + "" + NL + "  sem = rt_id2obj(semaphore_id);" + NL + "  if (sem == NULL) return osErrorParameter;" + NL + "" + NL + "  if (((P_SCB)sem)->cb_type != SCB) return osErrorParameter;" + NL + "" + NL + "  if (((P_SCB)sem)->tokens == osFeature_Semaphore) return osErrorResource;" + NL + "  " + NL + "  rt_sem_send(sem);                             // Release Semaphore" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "/// Delete a Semaphore that was created by osSemaphoreCreate" + NL + "osStatus svcSemaphoreDelete (osSemaphoreId semaphore_id) {" + NL + "  OS_ID sem;" + NL + "" + NL + "  sem = rt_id2obj(semaphore_id);" + NL + "  if (sem == NULL) return osErrorParameter;" + NL + "" + NL + "  if (((P_SCB)sem)->cb_type != SCB) return osErrorParameter;" + NL + "" + NL + "  rt_sem_delete(sem);                           // Delete Semaphore" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "" + NL + "// Semaphore ISR Calls" + NL + "" + NL + "/// Release a Semaphore" + NL + "static __INLINE osStatus isrSemaphoreRelease (osSemaphoreId semaphore_id) {" + NL + "  OS_ID sem;" + NL + "" + NL + "  sem = rt_id2obj(semaphore_id);" + NL + "  if (sem == NULL) return osErrorParameter;" + NL + "" + NL + "  if (((P_SCB)sem)->cb_type != SCB) return osErrorParameter;" + NL + "" + NL + "  if (((P_SCB)sem)->tokens == osFeature_Semaphore) return osErrorResource;" + NL + "" + NL + "  isr_sem_send(sem);                            // Release Semaphore" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "" + NL + "// Semaphore Public API" + NL + "" + NL + "/// Create and Initialize a Semaphore object" + NL + "osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count) {" + NL + "  if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR" + NL + "  if (((__get_CONTROL() & 1) == 0) && (os_running == 0)) {" + NL + "    // Privileged and not running" + NL + "    return   svcSemaphoreCreate(semaphore_def, count);" + NL + "  } else {" + NL + "    return __svcSemaphoreCreate(semaphore_def, count);" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Wait until a Semaphore becomes available" + NL + "int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec) {" + NL + "  if (__get_IPSR() != 0) return -1;             // Not allowed in ISR" + NL + "  return __svcSemaphoreWait(semaphore_id, millisec);" + NL + "}" + NL + "" + NL + "/// Release a Semaphore" + NL + "osStatus osSemaphoreRelease (osSemaphoreId semaphore_id) {" + NL + "  if (__get_IPSR() != 0) {                      // in ISR" + NL + "    return   isrSemaphoreRelease(semaphore_id);" + NL + "  } else {                                      // in Thread" + NL + "    return __svcSemaphoreRelease(semaphore_id);" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Delete a Semaphore that was created by osSemaphoreCreate" + NL + "osStatus osSemaphoreDelete (osSemaphoreId semaphore_id) {" + NL + "  if (__get_IPSR() != 0) return osErrorISR;     // Not allowed in ISR" + NL + "  return __svcSemaphoreDelete(semaphore_id);" + NL + "}" + NL + "" + NL + "" + NL + "// ==== Memory Management Functions ====" + NL + "" + NL + "// Memory Management Helper Functions" + NL + "" + NL + "// Clear Memory Box (Zero init)" + NL + "static void rt_clr_box (void *box_mem, void *box) {" + NL + "  uint32_t *p, n;" + NL + "" + NL + "  if (box) {" + NL + "    p = box;" + NL + "    for (n = ((P_BM)box_mem)->blk_size; n; n -= 4) {" + NL + "      *p++ = 0;" + NL + "    }" + NL + "  }" + NL + "}" + NL + "" + NL + "// Memory Management Service Calls declarations" + NL + "SVC_1_1(svcPoolCreate, osPoolId, const osPoolDef_t *,           RET_pointer)" + NL + "SVC_2_1(sysPoolAlloc,  void *,         osPoolId,      uint32_t, RET_pointer)" + NL + "SVC_2_1(sysPoolFree,   osStatus,       osPoolId,      void *,   RET_osStatus)" + NL + "" + NL + "// Memory Management Service & ISR Calls" + NL + "" + NL + "/// Create and Initialize memory pool" + NL + "osPoolId svcPoolCreate (const osPoolDef_t *pool_def) {" + NL + "  uint32_t blk_sz;" + NL + "" + NL + "  if ((pool_def == NULL) ||" + NL + "      (pool_def->pool_sz == 0) ||" + NL + "      (pool_def->item_sz == 0) ||" + NL + "      (pool_def->pool == NULL)) {" + NL + "    sysThreadError(osErrorParameter);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  blk_sz = (pool_def->item_sz + 3) & ~3;" + NL + "" + NL + "  _init_box(pool_def->pool, sizeof(struct OS_BM) + pool_def->pool_sz * blk_sz, blk_sz);" + NL + "" + NL + "  return pool_def->pool;" + NL + "}" + NL + "" + NL + "/// Allocate a memory block from a memory pool" + NL + "void *sysPoolAlloc (osPoolId pool_id, uint32_t clr) {" + NL + "  void *ptr;" + NL + "" + NL + "  if (pool_id == NULL) return NULL;" + NL + "" + NL + "  ptr = rt_alloc_box(pool_id);" + NL + "  if (clr) {" + NL + "    rt_clr_box(pool_id, ptr);" + NL + "  }" + NL + "" + NL + "  return ptr;" + NL + "}" + NL + "" + NL + "/// Return an allocated memory block back to a specific memory pool" + NL + "osStatus sysPoolFree (osPoolId pool_id, void *block) {" + NL + "  int32_t res;" + NL + "    " + NL + "  if (pool_id == NULL) return osErrorParameter;" + NL + "" + NL + "  res = rt_free_box(pool_id, block);" + NL + "  if (res != 0) return osErrorValue;" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "" + NL + "// Memory Management Public API" + NL + "" + NL + "/// Create and Initialize memory pool" + NL + "osPoolId osPoolCreate (const osPoolDef_t *pool_def) {" + NL + "  if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR" + NL + "  if (((__get_CONTROL() & 1) == 0) && (os_running == 0)) {" + NL + "    // Privileged and not running" + NL + "    return   svcPoolCreate(pool_def);" + NL + "  } else {" + NL;
  protected final String TEXT_8 = "    return __svcPoolCreate(pool_def);" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Allocate a memory block from a memory pool" + NL + "void *osPoolAlloc (osPoolId pool_id) {" + NL + "  if ((__get_IPSR() != 0) || ((__get_CONTROL() & 1) == 0)) {    // in ISR or Privileged" + NL + "    return   sysPoolAlloc(pool_id, 0);" + NL + "  } else {                                      // in Thread" + NL + "    return __sysPoolAlloc(pool_id, 0);" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Allocate a memory block from a memory pool and set memory block to zero" + NL + "void *osPoolCAlloc (osPoolId pool_id) {" + NL + "  if ((__get_IPSR() != 0) || ((__get_CONTROL() & 1) == 0)) {    // in ISR or Privileged" + NL + "    return   sysPoolAlloc(pool_id, 1);" + NL + "  } else {                                      // in Thread" + NL + "    return __sysPoolAlloc(pool_id, 1);" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Return an allocated memory block back to a specific memory pool" + NL + "osStatus osPoolFree (osPoolId pool_id, void *block) {" + NL + "  if ((__get_IPSR() != 0) || ((__get_CONTROL() & 1) == 0)) {    // in ISR or Privileged" + NL + "    return   sysPoolFree(pool_id, block);" + NL + "  } else {                                      // in Thread" + NL + "    return __sysPoolFree(pool_id, block);" + NL + "  }" + NL + "}" + NL + "" + NL + "" + NL + "// ==== Message Queue Management Functions ====" + NL + "" + NL + "// Message Queue Management Service Calls declarations" + NL + "SVC_2_1(svcMessageCreate,        osMessageQId, const osMessageQDef_t *, osThreadId,           RET_pointer)" + NL + "SVC_3_1(svcMessagePut,           osStatus,           osMessageQId,      uint32_t,   uint32_t, RET_osStatus)" + NL + "SVC_2_3(svcMessageGet, os_InRegs osEvent,            osMessageQId,      uint32_t,             RET_osEvent)" + NL + "" + NL + "// Message Queue Service Calls" + NL + "" + NL + "/// Create and Initialize Message Queue" + NL + "osMessageQId svcMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id) {" + NL + "" + NL + "  if ((queue_def == NULL) ||" + NL + "      (queue_def->queue_sz == 0) ||" + NL + "      (queue_def->pool == NULL)) {" + NL + "    sysThreadError(osErrorParameter);" + NL + "    return NULL;" + NL + "  }" + NL + "  " + NL + "  if (((P_MCB)queue_def->pool)->cb_type != 0) {" + NL + "    sysThreadError(osErrorParameter);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  rt_mbx_init(queue_def->pool, 4*(queue_def->queue_sz + 4));" + NL + "" + NL + "  return queue_def->pool;" + NL + "}" + NL + "" + NL + "/// Put a Message to a Queue" + NL + "osStatus svcMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec) {" + NL + "  OS_RESULT res;" + NL + "" + NL + "  if (queue_id == NULL) return osErrorParameter;" + NL + "" + NL + "  if (((P_MCB)queue_id)->cb_type != MCB) return osErrorParameter;" + NL + "" + NL + "  res = rt_mbx_send(queue_id, (void *)info, rt_ms2tick(millisec));" + NL + "" + NL + "  if (res == OS_R_TMO) {" + NL + "    return (millisec ? osErrorTimeoutResource : osErrorResource);" + NL + "  }" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "/// Get a Message or Wait for a Message from a Queue" + NL + "os_InRegs osEvent_type svcMessageGet (osMessageQId queue_id, uint32_t millisec) {" + NL + "  OS_RESULT res;" + NL + "  osEvent   ret;" + NL + "" + NL + "  if (queue_id == NULL) {" + NL + "    ret.status = osErrorParameter;" + NL + "    return osEvent_ret_status;" + NL + "  }" + NL + "" + NL + "  if (((P_MCB)queue_id)->cb_type != MCB) {" + NL + "    ret.status = osErrorParameter;" + NL + "    return osEvent_ret_status;" + NL + "  }" + NL + "" + NL + "  res = rt_mbx_wait(queue_id, &ret.value.p, rt_ms2tick(millisec));" + NL + "  " + NL + "  if (res == OS_R_TMO) {" + NL + "    ret.status = millisec ? osEventTimeout : osOK;" + NL + "    return osEvent_ret_value;" + NL + "  }" + NL + "" + NL + "  ret.status = osEventMessage;" + NL + "" + NL + "  return osEvent_ret_value;" + NL + "}" + NL + "" + NL + "" + NL + "// Message Queue ISR Calls" + NL + "" + NL + "/// Put a Message to a Queue" + NL + "static __INLINE osStatus isrMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec) {" + NL + "" + NL + "  if ((queue_id == NULL) || (millisec != 0)) {" + NL + "    return osErrorParameter;" + NL + "  }" + NL + "" + NL + "  if (((P_MCB)queue_id)->cb_type != MCB) return osErrorParameter;" + NL + "" + NL + "  if (rt_mbx_check(queue_id) == 0) {            // Check if Queue is full" + NL + "    return osErrorResource;" + NL + "  }" + NL + "" + NL + "  isr_mbx_send(queue_id, (void *)info);" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "/// Get a Message or Wait for a Message from a Queue" + NL + "static __INLINE os_InRegs osEvent isrMessageGet (osMessageQId queue_id, uint32_t millisec) {" + NL + "  OS_RESULT res;" + NL + "  osEvent   ret;" + NL + "" + NL + "  if ((queue_id == NULL) || (millisec != 0)) {" + NL + "    ret.status = osErrorParameter;" + NL + "    return ret;" + NL + "  }" + NL + "" + NL + "  if (((P_MCB)queue_id)->cb_type != MCB) {" + NL + "    ret.status = osErrorParameter;" + NL + "    return ret;" + NL + "  }" + NL + "" + NL + "  res = isr_mbx_receive(queue_id, &ret.value.p);" + NL + "  " + NL + "  if (res != OS_R_MBX) {" + NL + "    ret.status = osOK;" + NL + "    return ret;" + NL + "  }" + NL + "" + NL + "  ret.status = osEventMessage; " + NL + "" + NL + "  return ret;" + NL + "}" + NL + "" + NL + "" + NL + "// Message Queue Management Public API" + NL + "" + NL + "/// Create and Initialize Message Queue" + NL + "osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id) {" + NL + "  if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR" + NL + "  if (((__get_CONTROL() & 1) == 0) && (os_running == 0)) {" + NL + "    // Privileged and not running" + NL + "    return   svcMessageCreate(queue_def, thread_id);" + NL + "  } else {" + NL + "    return __svcMessageCreate(queue_def, thread_id);" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Put a Message to a Queue" + NL + "osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec) {" + NL + "  if (__get_IPSR() != 0) {                      // in ISR" + NL + "    return   isrMessagePut(queue_id, info, millisec);" + NL + "  } else {                                      // in Thread" + NL + "    return __svcMessagePut(queue_id, info, millisec);" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Get a Message or Wait for a Message from a Queue" + NL + "os_InRegs osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec) {" + NL + "  if (__get_IPSR() != 0) {                      // in ISR" + NL + "    return   isrMessageGet(queue_id, millisec);" + NL + "  } else {                                      // in Thread" + NL + "    return __svcMessageGet(queue_id, millisec);" + NL + "  }" + NL + "}" + NL + "" + NL + "" + NL + "// ==== Mail Queue Management Functions ====" + NL + "" + NL + "// Mail Queue Management Service Calls declarations" + NL + "SVC_2_1(svcMailCreate, osMailQId, const osMailQDef_t *, osThreadId,                   RET_pointer)" + NL + "SVC_4_1(sysMailAlloc,  void *,          osMailQId,      uint32_t, uint32_t, uint32_t, RET_pointer)" + NL + "SVC_3_1(sysMailFree,   osStatus,        osMailQId,      void *,   uint32_t,           RET_osStatus)" + NL + "" + NL + "// Mail Queue Management Service & ISR Calls" + NL + "" + NL + "/// Create and Initialize mail queue" + NL + "osMailQId svcMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id) {" + NL + "  uint32_t blk_sz;" + NL + "  P_MCB    pmcb;" + NL + "  void    *pool;" + NL + "" + NL + "  if ((queue_def == NULL) ||" + NL + "      (queue_def->queue_sz == 0) ||" + NL + "      (queue_def->item_sz  == 0) ||" + NL + "      (queue_def->pool == NULL)) {" + NL + "    sysThreadError(osErrorParameter);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  pmcb = *(((void **)queue_def->pool) + 0);" + NL + "  pool = *(((void **)queue_def->pool) + 1);" + NL + "" + NL + "  if ((pool == NULL) || (pmcb == NULL) || (pmcb->cb_type != 0)) {" + NL + "    sysThreadError(osErrorParameter);" + NL + "    return NULL;" + NL + "  }" + NL + "" + NL + "  blk_sz = (queue_def->item_sz + 3) & ~3;" + NL + "" + NL + "  _init_box(pool, sizeof(struct OS_BM) + queue_def->queue_sz * blk_sz, blk_sz);" + NL + "" + NL + "  rt_mbx_init(pmcb, 4*(queue_def->queue_sz + 4));" + NL + "" + NL + "  return queue_def->pool;" + NL + "}" + NL + "" + NL + "/// Allocate a memory block from a mail" + NL + "void *sysMailAlloc (osMailQId queue_id, uint32_t millisec, uint32_t isr, uint32_t clr) {" + NL + "  P_MCB pmcb;" + NL + "  void *pool;" + NL + "  void *mem;" + NL + "" + NL + "  if (queue_id == NULL) return NULL;" + NL + "" + NL + "  pmcb = *(((void **)queue_id) + 0);" + NL + "  pool = *(((void **)queue_id) + 1);" + NL + "" + NL + "  if ((pool == NULL) || (pmcb == NULL)) return NULL;" + NL + "" + NL + "  if (isr && (millisec != 0)) return NULL;" + NL + "" + NL + "  mem = rt_alloc_box(pool);" + NL + "  if (clr) {" + NL + "    rt_clr_box(pool, mem);" + NL + "  }" + NL + "" + NL + "  if ((mem == NULL) && (millisec != 0)) {" + NL + "    // Put Task to sleep when Memory not available" + NL + "    if (pmcb->p_lnk != NULL) {" + NL + "      rt_put_prio((P_XCB)pmcb, os_tsk.run);" + NL + "    } else {" + NL + "      pmcb->p_lnk = os_tsk.run;" + NL + "      os_tsk.run->p_lnk = NULL;" + NL + "      os_tsk.run->p_rlnk = (P_TCB)pmcb;" + NL + "      // Task is waiting to allocate a message" + NL + "      pmcb->state = 3;" + NL + "    }" + NL + "    rt_block(rt_ms2tick(millisec), WAIT_MBX);" + NL + "  }" + NL + "" + NL + "  return mem;  " + NL + "}" + NL + "" + NL + "/// Free a memory block from a mail" + NL + "osStatus sysMailFree (osMailQId queue_id, void *mail, uint32_t isr) {" + NL + "  P_MCB   pmcb;" + NL + "  P_TCB   ptcb;" + NL + "  void   *pool;" + NL + "  void   *mem;" + NL + "  int32_t res;" + NL + "" + NL + "  if (queue_id == NULL) return osErrorParameter;" + NL + "" + NL + "  pmcb = *(((void **)queue_id) + 0);" + NL + "  pool = *(((void **)queue_id) + 1);" + NL + "" + NL + "  if ((pmcb == NULL) || (pool == NULL)) return osErrorParameter;" + NL + "" + NL + "  res = rt_free_box(pool, mail);" + NL + "" + NL + "  if (res != 0) return osErrorValue;" + NL + "" + NL + "  if ((pmcb->p_lnk != NULL) && (pmcb->state == 3)) {" + NL + "    // Task is waiting to allocate a message" + NL + "    if (isr) {" + NL + "      rt_psq_enq (pmcb, (U32)pool);" + NL + "      rt_psh_req ();" + NL + "    } else {" + NL + "      mem = rt_alloc_box(pool);" + NL + "      if (mem != NULL) {" + NL + "        ptcb = rt_get_first((P_XCB)pmcb);" + NL + "        rt_ret_val(ptcb, (U32)mem);" + NL + "        rt_rmv_dly(ptcb);" + NL + "        rt_dispatch(ptcb);" + NL + "      }" + NL + "    }" + NL + "  }" + NL + "" + NL + "  return osOK;" + NL + "}" + NL + "" + NL + "" + NL + "// Mail Queue Management Public API" + NL + "" + NL + "/// Create and Initialize mail queue" + NL + "osMailQId osMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id) {" + NL + "  if (__get_IPSR() != 0) return NULL;           // Not allowed in ISR" + NL + "  if (((__get_CONTROL() & 1) == 0) && (os_running == 0)) {" + NL + "    // Privileged and not running" + NL + "    return   svcMailCreate(queue_def, thread_id);" + NL + "  } else {" + NL + "    return __svcMailCreate(queue_def, thread_id);" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Allocate a memory block from a mail" + NL + "void *osMailAlloc (osMailQId queue_id, uint32_t millisec) {" + NL + "  if (__get_IPSR() != 0) {                      // in ISR" + NL + "    return   sysMailAlloc(queue_id, millisec, 1, 0);" + NL + "  } else {                                      // in Thread" + NL + "    return __sysMailAlloc(queue_id, millisec, 0, 0);" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Allocate a memory block from a mail and set memory block to zero" + NL + "void *osMailCAlloc (osMailQId queue_id, uint32_t millisec) {" + NL + "  if (__get_IPSR() != 0) {                      // in ISR" + NL + "    return   sysMailAlloc(queue_id, millisec, 1, 1);" + NL + "  } else {                                      // in Thread" + NL + "    return __sysMailAlloc(queue_id, millisec, 0, 1);" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Free a memory block from a mail" + NL + "osStatus osMailFree (osMailQId queue_id, void *mail) {" + NL + "  if (__get_IPSR() != 0) {                      // in ISR" + NL + "    return   sysMailFree(queue_id, mail, 1);" + NL + "  } else {                                      // in Thread" + NL + "    return __sysMailFree(queue_id, mail, 0);" + NL + "  }" + NL + "}" + NL + "" + NL + "/// Put a mail to a queue" + NL + "osStatus osMailPut (osMailQId queue_id, void *mail) {" + NL + "  if (queue_id == NULL) return osErrorParameter;" + NL + "  if (mail == NULL)     return osErrorValue;" + NL + "  return osMessagePut(*((void **)queue_id), (uint32_t)mail, 0);" + NL + "}" + NL + "" + NL + "/// Get a mail from a queue" + NL + "os_InRegs osEvent osMailGet (osMailQId queue_id, uint32_t millisec) {" + NL + "  osEvent ret;" + NL + "" + NL + "  if (queue_id == NULL) {" + NL + "    ret.status = osErrorParameter;" + NL + "    return ret;" + NL + "  }" + NL + "" + NL + "  ret = osMessageGet(*((void **)queue_id), millisec);" + NL + "  if (ret.status == osEventMessage) ret.status = osEventMail;" + NL + "" + NL + "  return ret;" + NL + "}" + NL + "" + NL + "" + NL + "//  ==== RTX Extensions ====" + NL + "" + NL + "// Service Calls declarations" + NL + "SVC_0_1(rt_suspend, uint32_t, RET_uint32_t)" + NL + "SVC_1_0(rt_resume,  void,     uint32_t)" + NL + "" + NL + "" + NL + "// Public API" + NL + "" + NL + "/// Suspends the OS task scheduler" + NL + "uint32_t os_suspend (void) {" + NL + "  return __rt_suspend();" + NL + "}" + NL + "" + NL + "/// Resumes the OS task scheduler" + NL + "void os_resume (uint32_t sleep_time) {" + NL + "  __rt_resume(sleep_time);" + NL + "}";
  protected final String TEXT_9 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     if (app.getSoftwareId().substring(0,1).compareTo("4") == 0) { 
    stringBuffer.append(TEXT_2);
     } 
     else if (app.getSoftwareId().substring(0,1).compareTo("1") == 0) { 
    stringBuffer.append(TEXT_3);
     } 
    stringBuffer.append(TEXT_4);
    stringBuffer.append(TEXT_5);
    stringBuffer.append(TEXT_6);
    stringBuffer.append(TEXT_7);
    stringBuffer.append(TEXT_8);
    stringBuffer.append(TEXT_9);
    return stringBuffer.toString();
  }
}
