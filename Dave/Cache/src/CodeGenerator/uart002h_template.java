package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class uart002h_template
{
  protected static String nl;
  public static synchronized uart002h_template create(String lineSeparator)
  {
    nl = lineSeparator;
    uart002h_template result = new uart002h_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "/*CODE_BLOCK_BEGIN[UART002.h]*/" + NL + "/*****************************************************************************" + NL + " *" + NL + " * Copyright (C) 2013 Infineon Technologies AG. All rights reserved." + NL + " *" + NL + " * Infineon Technologies AG (Infineon) is supplying this software for use with " + NL + " * Infineon's microcontrollers.  " + NL + " * This file can be freely distributed within development tools that are " + NL + " * supporting such microcontrollers. " + NL + " *" + NL + " * THIS SOFTWARE IS PROVIDED \"AS IS\".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED" + NL + " * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF" + NL + " * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE." + NL + " * INFINEON SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, " + NL + " * OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER." + NL + " *" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000/XMC1000 Series                                 **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR   : App Developer                                                   **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/No]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Apr 17, 2013                                           **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials     Name                                                          **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** AIK        App Developer                                                   **" + NL + "*******************************************************************************/" + NL + "" + NL + "/**" + NL + " * @file UART002.h" + NL + " * " + NL + " * @brief Header file for UART002 App" + NL + " *" + NL + " */" + NL + "/* " + NL + "* Version History : " + NL + "* 17 Apr 2013 v1.0.8\t1. Replaced \"DMA003_H_\" Macro with \t\"UART_DMA_ENABLED\"   " + NL + "*                       2. Removed #ifndef DMA004_H_ statement because its " + NL + "*                       unused in the logic                                           " + NL + "*                       3. Spell Corrections  " + NL + "*                       4. Changed type of desired baudrate parameter from " + NL + "*                       uint16_t to uint32_t to support badrate range upto 2Mbps." + NL + "*                       5. Modified the structure UART002_HandleType to add baud " + NL + "*                       parameters for the baud rate." + NL + "*                       6. DMA mode handling is disabled for XMC1000 devices " + NL + "*                       as DMA module is not available in XMC1000 devices.     " + NL + "*                                                     " + NL + "*******************************************************************************/" + NL + "" + NL + "#ifndef UART002_H_" + NL + "#define UART002_H_" + NL + "" + NL + "#ifdef __cplusplus" + NL + "extern \"C\" {" + NL + "#endif" + NL;
  protected final String TEXT_2 = NL;
  protected final String TEXT_3 = NL;
  protected final String TEXT_4 = NL + "#define UART_DMA_ENABLED";
  protected final String TEXT_5 = "  ";
  protected final String TEXT_6 = NL + "/* CHANNEL IS NOT MAPPED */";
  protected final String TEXT_7 = NL + NL + "/*******************************************************************************" + NL + "**                      Include Files                                         **" + NL + "*******************************************************************************/" + NL + "#include <DAVE3.h>" + NL + "/* Inclusion of Platform specific file */" + NL + "#include \"../../inc/UART002/Usic.h\"" + NL + "" + NL + "#if defined (__GNUC__)" + NL + "#include <sys/time.h>" + NL + "#elif defined(__TASKING__)" + NL + "#include <time.h>" + NL + "#endif" + NL;
  protected final String TEXT_8 = NL + "#ifdef UART_DMA_ENABLED" + NL + "#include \"../../inc/DMA003/DMA003.h\"" + NL + "#endif ";
  protected final String TEXT_9 = NL + "/*******************************************************************************" + NL + "**                      Global Macro Definitions                              **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "" + NL + " /*******************************************************************************" + NL + "**                      Global Type Definitions                               **" + NL + "*******************************************************************************/" + NL + "" + NL + "/**" + NL + " * @ingroup UART002_publicparam" + NL + " * @{" + NL + " */" + NL + "" + NL + "/**" + NL + " * This enum structure list the possible status values returned" + NL + " * by API functions." + NL + " */" + NL + "typedef enum UART002_StatusType" + NL + "{" + NL + "  /**" + NL + "   * Uart channel in Idle state" + NL + "   */" + NL + "  /*" + NL + "\tGROUPID  #4" + NL + "\tMODULENAME = UART002" + NL + "  */" + NL + "  /*" + NL + "\tERRCODESTRING = UART002_IDLE" + NL + "\tSTRCODESTRING = Uart Channel in idle state" + NL + "  */" + NL + "  UART002_IDLE = 1," + NL + "   /**" + NL + "   * Uart transfer pending" + NL + "   */" + NL + "  /*" + NL + "\tERRCODESTRING = UART002_TRANSFER_PENDING" + NL + "\tSTRCODESTRING = Uart transfer pending" + NL + "  */" + NL + "  UART002_TRANSFER_PENDING," + NL + "  /**" + NL + "   * Uart transfer successful" + NL + "   */" + NL + "  /*" + NL + "\tERRCODESTRING = UART002_TRANSFER_SUCCESS" + NL + "\tSTRCODESTRING = Uart transfer successful" + NL + "  */" + NL + "  UART002_TRANSFER_SUCCESS," + NL + "  /**" + NL + "   * Uart transfer failed" + NL + "   */" + NL + "  /*" + NL + "\tERRCODESTRING = UART002_TRANSFER_FAILED" + NL + "\tSTRCODESTRING = Uart transfer failed" + NL + "  */" + NL + "  UART002_TRANSFER_FAILED," + NL + "  /**" + NL + "   * Invalid Input value" + NL + "   */" + NL + "  /*" + NL + "\tERRCODESTRING = UART002_CONFIG_ERROR" + NL + "\tSTRCODESTRING = Uart Input error" + NL + "  */" + NL + "  UART002_CONFIG_ERROR," + NL + "  /**" + NL + "   * Time out occured" + NL + "   */" + NL + "  /*" + NL + "\tERRCODESTRING = UART002_TIMEOUT" + NL + "\tSTRCODESTRING =  Time out occured" + NL + "  */" + NL + "  UART002_TIMEOUT," + NL + "  /**" + NL + "   * Semaphore creation, wait or release failed" + NL + "   */" + NL + "  /*" + NL + "\tERRCODESTRING = UART002_SEMAPHORE_ERROR" + NL + "\tSTRCODESTRING = Semaphore creation, wait or release failed" + NL + "  */" + NL + "  UART002_SEMAPHORE_ERROR," + NL + "  /**" + NL + "   * DMA initialisation error" + NL + "   */" + NL + "  /*" + NL + "\tERRCODESTRING = UART002_DMA_ERROR" + NL + "\tSTRCODESTRING = DMA initialization error" + NL + "  */" + NL + "  UART002_DMA_ERROR," + NL + "  /**" + NL + "   * Unknown Error" + NL + "   */" + NL + "  /*" + NL + "\tERRCODESTRING = UART002_FAIL" + NL + "\tSTRCODESTRING = Unknown Error" + NL + "  */" + NL + "  UART002_FAIL," + NL + "  /**" + NL + "   * Function Entry" + NL + "   */" + NL + "  /*" + NL + "\tERRCODESTRING = UART001_FUN_ENTRY" + NL + "\tSTRCODESTRING = Entered function %s" + NL + "  */" + NL + "  UART002_FUN_ENTRY," + NL + "  /**" + NL + "   *  Function Exit" + NL + "   */" + NL + "  /*" + NL + "\tERRCODESTRING = UART001_FUN_EXIT" + NL + "\tSTRCODESTRING = Exited function %s" + NL + "  */" + NL + "  UART002_FUN_EXIT" + NL + "   /*" + NL + "\tERRORCODEEND" + NL + "  */" + NL + "}UART002_StatusType;" + NL;
  protected final String TEXT_10 = NL + "/**" + NL + " * This enumerations defines DMA modes which is used by App." + NL + " */" + NL + "typedef enum UART002_DMAType" + NL + "{" + NL + "  /** Non DMA mode*/" + NL + "  UART002_DMA_NONE," + NL + "  /** Uart reception in DMA mode*/" + NL + "  UART002_RX_DMA," + NL + "  /** UART Transmission in DMA mode*/" + NL + "  UART002_TX_DMA," + NL + "  /** Transmission and reception both in DMA mode*/" + NL + "  UART002_RX_TX_DMA," + NL + "} UART002_DMAType;";
  protected final String TEXT_11 = NL + "/**" + NL + " * This data structure contains all Uart channel parameters which are configured from the " + NL + " * Application UI." + NL + " */" + NL + "typedef struct UART002_ChannelConfigType" + NL + "{" + NL + "  /** Enumerated Parity field*/" + NL + "  UART_ParityType Parity;" + NL + "  /** Enumerated Stop bit field*/" + NL + "  UART_StopBitType StopBit;" + NL + "  /** Desired Baud Rate */" + NL + "  uint32_t  BaudRate;" + NL + "  /** Word Length */" + NL + "  uint16_t DataBits;" + NL + "}UART002_ChannelConfigType;" + NL + "/**" + NL + " * This data structure is used by a Task to specify transfer parameters." + NL + " * " + NL + " */" + NL + "typedef struct  UART002_LocalStructType" + NL + "{" + NL + "  /**App Handle*/" + NL + "  uint32_t* AppInstanceHandle;" + NL + "  /** Length of data to be transmitted or received */" + NL + "  uint16_t DataLen;" + NL + "  /**Pointer to buffer */" + NL + "  uint8_t* pBuffer;" + NL + "  /** Data transfer status copied  at the end of transfer*/" + NL + "  UART002_StatusType  Status;" + NL + "  /** Job Signal ID passed by Job task */" + NL + "  int32_t SignalId;" + NL + "  /** Job Thread ID */" + NL + "  osThreadId ThreadID;" + NL + "}UART002_LocalStructType;" + NL + "" + NL + "" + NL + "typedef struct UART002_DynamicDataType" + NL + "{" + NL + "  /** Reference to Local Task Structure */\t" + NL + "  UART002_LocalStructType* CurrentTaskStruct;" + NL + "  /** Uart channel semaphore ID */" + NL + "  osSemaphoreId  ChannelSemId;" + NL + "  /** Total Data Length to be received/transmitted*/" + NL + "  int16_t DataLen;" + NL + "  /** Pointer to buffer */" + NL + "  uint8_t* pBuffer;" + NL + "  uint8_t Msize;" + NL + "}UART002_DynamicDataType;" + NL + "/**" + NL + " * This data structure is the App Handle." + NL + " */" + NL + "typedef struct UART002_HandleType" + NL + "{";
  protected final String TEXT_12 = "\t" + NL + "#ifdef UART_DMA_ENABLED" + NL + "  /** Tx DMA Handle        */" + NL + "  DMA003_ChannelHandleType* TxDMAHandle;" + NL + "  /** Rx DMA Handle         */" + NL + "  DMA003_ChannelHandleType* RxDMAHandle;" + NL + "#endif ";
  protected final String TEXT_13 = NL + "  /** Current task dynamic data */" + NL + "  UART002_DynamicDataType* DynamicData;" + NL + "  /** Default Channel settings */" + NL + "  UART002_ChannelConfigType ChConfig;" + NL + "  /** CMSIS defined structure for USIC module */" + NL + "  USIC_CH_TypeDef* UartRegs;" + NL + "  /** UART mode of operation */" + NL + "  UART_ModeType Mode;";
  protected final String TEXT_14 = NL + "  /** DMA mode of operation */" + NL + "  UART002_DMAType DMAMode;";
  protected final String TEXT_15 = NL + "  /** Rx FIFO Trigger level */" + NL + "  uint8_t RxFIFOTrigger;" + NL + "  /** Rx FIFO Trigger level*/" + NL + "  uint8_t TxFIFOTrigger;" + NL + "  /** Calculated step value */" + NL + "  uint16_t BGR_STEP;" + NL + "  /** Calculated pdiv value */" + NL + "  uint16_t BGR_PDIV;" + NL + "  /** Calculated  dctq value */" + NL + "  uint16_t BGR_DCTQ;" + NL + "  /** Calculated  sampling point value */" + NL + "  /** SP = (((1+dctq)/2)+1) */" + NL + "  uint16_t BGR_SP;" + NL + "  /** Calculated  pctq value */" + NL + "  uint8_t BGR_PCTQ;" + NL + "}UART002_HandleType;" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Constant Declarations                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Extern Variables                                      **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "** FUNCTION PROTOTYPES                                                        **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/**" + NL + " * @ingroup UART002_apidoc" + NL + " * @{" + NL + " */" + NL + "" + NL + "" + NL + "/**" + NL + " * Initialises the USIC channel reserved for the App based on" + NL + " * provided configuration." + NL + " *" + NL + " *" + NL + " * <b>Reentrant: No </b><BR>" + NL + " * " + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   " + NL + " *   DAVE_Init(); // UART002_Init will be called from DAVE_Init()" + NL + " *   while(1)" + NL + " *   {}" + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode<BR> </p>" + NL + " *" + NL + " */" + NL + "void UART002_Init(void);" + NL + "" + NL + "" + NL + "/**" + NL + " * Function to reset the App configurable parameters to default values.<br>" + NL + " * Note: Currently this function is a place holder function. " + NL + " *" + NL + " * @param[in]  Handle  App instance handle object." + NL + " *" + NL + " *" + NL + " * <b>Reentrant: YES </b><BR>" + NL + " *" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " * int main(void)" + NL + " * {" + NL + " *   // ...." + NL + " *   UART002_DeInit(&UART001_Handle0);" + NL + " *   //...." + NL + " *   return 0;" + NL + " * }" + NL + " * @endcode<BR> </p>" + NL + " */" + NL + "void UART002_Deinit(const UART002_HandleType* Handle);" + NL + "" + NL + "" + NL + "/**" + NL + " * This function initialises the Local Data structure allocated by" + NL + " *           the Task/App with default values. This function also copies the App" + NL + " *           handle to the local data structure." + NL + " *" + NL + " * @param[in]  Handle App instance handle." + NL + " * @param[in]  Config  Local structure object." + NL + " * @param[in]  SignalId specifies the unique signal flag of the thread.(uint32_t)" + NL + " *             Note: On Transfer completion this signal is set, thus signalling " + NL + " *             the waiting Task(see UART002_WaitForCompletion() API) of Job completion." + NL + " * " + NL + " * <b>Reentrant: YES </b><BR>" + NL + " * " + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * // Forward reference " + NL + " * void threadA (void const *argument);" + NL + " *" + NL + " * // Thread IDs" + NL + " * osThreadId threadA_id;" + NL + " *" + NL + " * //Thread definitions " + NL + " * osThreadDef(threadA, osPriorityNormal, 1, 0);" + NL + " * // HELLO WORLD" + NL + " * uint8_t Data[12] = {0x48,0x45,0x4C,0x4C,0x4F,0x20,0x57,0x4F,0x52,0x4C,0x44,0x20};" + NL + " *  " + NL + " * void threadA(void const *argument)" + NL + " * {" + NL + " *\t status_t Status = UART002_FAIL;" + NL + " *\t UART002_LocalStructType TxChn;" + NL + " *\t // Initialise the local structure with default parameters." + NL + " *\t UART002_LocalStructureInit(&UART002_Handle0,&TxChn,0x0001);" + NL + " *\t // Change the configuration based on use case." + NL + " *\t TxChn.DataLen = 12;" + NL + " *\t TxChn.pBuffer = &Data[0];" + NL + " *" + NL + " *   while(1)" + NL + " *   {" + NL + " *\t  " + NL + " *\t\tStatus = UART002_StartTransmission(&TxChn,1000);" + NL + " *\t\tif(Status == UART002_TIMEOUT)" + NL + " *\t\t{" + NL + " *\t\t\tStatus = UART002_FAIL;" + NL + " *\t\t}" + NL + " *\t\telse" + NL + " *\t\t{" + NL + " *\t\t\tStatus = UART002_WaitForCompletion(&TxChn,10000);" + NL + " *\t\t\tif(Status != UART002_TIMEOUT)" + NL + " *\t\t\t{" + NL + " *" + NL + " *\t\t\t\tStatus = UART002_GetStatus(&TxChn);" + NL + " *\t\t\t\tif(Status != UART002_TRANSFER_SUCCESS)" + NL + " *\t\t\t\t{" + NL + " *\t\t\t\t\t\tStatus = UART002_FAIL;" + NL + " *\t\t\t\t}" + NL + " *\t\t\t}" + NL + " *\t\t}" + NL + " *   }" + NL + " *" + NL + " *  }" + NL + " *\t" + NL + " *  int main (void)" + NL + " *  {" + NL + " *    " + NL + " *    DAVE_Init();" + NL + " *" + NL + " *    // Create thread X " + NL + " *    threadA_id = osThreadCreate(osThread(threadA), NULL);" + NL + " *" + NL + " *    osKernelStart();" + NL + " *" + NL + " *    while(1)" + NL + " *    {" + NL + " *\t    osDelay(1000);" + NL + " *    }" + NL + " *  }" + NL + " * @endcode<BR> </p>" + NL + " */" + NL + "void UART002_LocalStructureInit" + NL + "(" + NL + "  const UART002_HandleType* Handle," + NL + "  UART002_LocalStructType* Config," + NL + "  int32_t SignalId" + NL + ");" + NL + "" + NL + "" + NL + "/**" + NL + " * This function starts the  UART Reception . The Config structure" + NL + " *           has the desired no of bytes to be received from the peer device." + NL + " *           Timeout value is specified." + NL + " *" + NL + " *" + NL + " * @param[in]  Config  Local structure object." + NL + " * @param[in]  Timeout Timeout value in msec." + NL + " *             use <b>osWaitForever</b> for indefinite timeout." + NL + " *" + NL + " * @return     status_t <BR>" + NL + " *              DAVEApp_SUCCESS \t\t: if Successful <BR>" + NL + " *              UART002_TIMEOUT \t\t: Timeout value in case Channel is not available <BR>" + NL + " *              UART002_CONFIG_ERROR \t: if there is a wrong configuration <BR>" + NL + " *              UART002_DMA_ERROR \t\t: if DMA initialisation fails<BR>" + NL + " *" + NL + " *" + NL + " * <b>Reentrant: YES </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * // Forward reference " + NL + " * void threadA (void const *argument);" + NL + " *" + NL + " * // Thread IDs" + NL + " * osThreadId threadA_id;" + NL + " *" + NL + " *" + NL + " * //Thread definitions " + NL + " * osThreadDef(threadA, osPriorityNormal, 1, 0);" + NL + " *" + NL + " * uint8_t Data[20]; // Buffer to store received data" + NL + " *  " + NL + " *  void threadA(void const *argument)" + NL + " *  {" + NL + " *  \tstatus_t Status = UART002_FAIL;" + NL + " *  \tUART002_LocalStructtype RxChn;" + NL + " *  \tUART002_LocalStructureInit(&UART002_Handle0,&RxChn,0x0001);" + NL + " *  \tRxChn.DataLen = 11;" + NL + " *  \tRxChn.pBuffer = &Data[0];" + NL + " *  \t " + NL + " *  \tStatus = UART002_StartReception(&RxChn,osWaitForever);" + NL + " *  \tif(Status == UART002_TIMEOUT)" + NL + " *  \t{" + NL + " *  \t\tStatus = UART002_FAIL;" + NL + " *  \t}" + NL + " *  \telse" + NL + " *  \t{" + NL + " *  " + NL + " *  \t\tStatus = UART002_WaitForCompletion(&RxChn,osWaitForever);" + NL + " *  \t\tif(Status != UART002_TIMEOUT)" + NL + " *  \t\t{" + NL + " *  " + NL + " *  \t\t\tStatus = UART002_GetStatus(&RxChn);" + NL + " *  \t\t\tif(Status != UART002_TRANSFER_SUCCESS)" + NL + " *  \t\t\t{" + NL + " *  \t\t\t\t\tStatus = UART002_FAIL;" + NL + " *  \t\t\t}" + NL + " *  \t\t}" + NL + " *  \t}" + NL + " *  " + NL + " *  }" + NL + " *  " + NL + " *\t" + NL + " *  int main (void)" + NL + " *  {" + NL + " *    " + NL + " *    DAVE_Init();" + NL + " *" + NL + " *    // Create thread X " + NL + " *    threadA_id = osThreadCreate(osThread(threadA), NULL);" + NL + " *" + NL + " *    osKernelStart();" + NL + " *" + NL + " *    while(1)" + NL + " *    {" + NL + " *\t    osDelay(1000);" + NL + " *    }" + NL + " *  }" + NL + " * @endcode<BR> </p>" + NL + " *" + NL + " */" + NL + "status_t UART002_StartReception" + NL + "(" + NL + "  UART002_LocalStructType* Config," + NL + "  time_t Timeout" + NL + ");" + NL + "" + NL + "" + NL + "/**" + NL + " * This function starts the  UART Transmission. The Config structure" + NL + " *           has the desired no of bytes to be transmitted to the peer device." + NL + " *           Timeout value is also specified in case the channel is occupied by" + NL + " *           some other task." + NL + " *" + NL + " *" + NL + " * @param[in]  Config Local structure object." + NL + " * @param[in]  Timeout Timeout value in msec." + NL + " *             use <b>osWaitForever</b> for indefinite timeout." + NL + " *" + NL + " * @return      status_t <BR>" + NL + " *              DAVEApp_SUCCESS \t\t: if Successful <BR>" + NL + " *              UART002_TIMEOUT \t\t: Timeout value in case Channel is not available <BR>" + NL + " *              UART002_CONFIG_ERROR \t: if there is a wrong configuration <BR>" + NL + " *              UART002_DMA_ERROR \t\t: if DMA initialisation fails <BR>" + NL + " *" + NL + " *" + NL + " * <b>Reentrant: YES </b><BR>" + NL + " * <BR><P ALIGN=\"LEFT\"><B>Example:</B>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * // Forward reference " + NL + " * void threadA (void const *argument);" + NL + " *" + NL + " * // Thread IDs" + NL + " * osThreadId threadA_id;" + NL + " *" + NL + " *" + NL + " * //Thread definitions " + NL + " * osThreadDef(threadA, osPriorityNormal, 1, 0);" + NL + " * // HELLO WORLD" + NL + " * uint8_t Data[12] = {0x48,0x45,0x4C,0x4C,0x4F,0x20,0x57,0x4F,0x52,0x4C,0x44,0x20};" + NL + " *  " + NL + " * void threadA(void const *argument)" + NL + " * {" + NL + " *\t status_t Status = UART002_FAIL;" + NL + " *\t UART002_LocalStructType TxChn;" + NL + " *\t UART002_LocalStructureInit(&UART002_Handle0,&TxChn,0x0001);" + NL + " *\t TxChn.DataLen = 12;" + NL + " *\t TxChn.pBuffer = &Data[0];" + NL + " *" + NL + " *\t while(1)" + NL + " *\t {" + NL + " *\t  //osDelay(1000);" + NL + " *\t\tStatus = UART002_StartTransmission(&TxChn,1000);" + NL + " *\t\tif(Status == UART002_TIMEOUT)" + NL + " *\t\t{" + NL + " *\t\t\tStatus = UART002_FAIL;" + NL + " *\t\t}" + NL + " *\t\telse" + NL + " *\t\t{" + NL + " *\t\t\tStatus = UART002_WaitForCompletion(&TxChn,1000);" + NL + " *\t\t\tif(Status != UART002_TIMEOUT)" + NL + " *\t\t\t{" + NL + " *" + NL + " *\t\t\t\tStatus = UART002_GetStatus(&TxChn);" + NL + " *\t\t\t\tif(Status != UART002_TRANSFER_SUCCESS)" + NL + " *\t\t\t\t{" + NL + " *\t\t\t\t\t\tStatus = UART002_FAIL;" + NL + " *\t\t\t\t}" + NL + " *\t\t\t}" + NL + " *\t\t}" + NL + " *\t }" + NL + " * }" + NL + " *" + NL + " *" + NL + " *\t" + NL + " *  int main (void)" + NL + " *  {" + NL + " *   " + NL + " *   DAVE_Init();" + NL + " *" + NL + " *  // Create thread X " + NL + " *  threadA_id = osThreadCreate(osThread(threadA), NULL);" + NL + " *" + NL + " *  osKernelStart();" + NL + " *" + NL + " *  while(1)" + NL + " *  {" + NL + " *\t  osDelay(1000);" + NL + " *  }" + NL + " *}" + NL + " * @endcode<BR> </p>" + NL + " *" + NL + " */" + NL + "status_t UART002_StartTransmission(UART002_LocalStructType* Config, time_t Timeout);" + NL + "" + NL + "" + NL + "/**" + NL + " * This function blocks the task till transfer completion if timeout" + NL + " *             value of 0 specified or till specified  timeout occurs" + NL + " *" + NL + " *" + NL + " * @param[in]  Config  Local structure object." + NL + " * @param[in]  Timeout Timeout value" + NL + " *" + NL + " * @return     status_t <BR>" + NL + " *              DAVEApp_SUCCESS \t\t: if Successful <BR>" + NL + " *              UART002_TIMEOUT \t\t: Timeout happened since transmission or reception" + NL + " *                               \t  \t  is not completed within timeout value <BR>" + NL + " *              UART002_SEMAPHORE_ERROR\t: if release of semaphore fails<BR>" + NL + " *" + NL + " *" + NL + " * <b>Reentrant: YES </b><BR>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * // Forward reference " + NL + " * void threadA (void const *argument);" + NL + " *" + NL + " * // Thread IDs" + NL + " * osThreadId threadA_id;" + NL + " *" + NL + " *" + NL + " * //Thread definitions " + NL + " * osThreadDef(threadA, osPriorityNormal, 1, 0);" + NL + " * // HELLO WORLD" + NL + " * uint8_t Data[12] = {0x48,0x45,0x4C,0x4C,0x4F,0x20,0x57,0x4F,0x52,0x4C,0x44,0x20};" + NL + " *  " + NL + " * void threadA(void const *argument)" + NL + " * {" + NL + " *\t status_t Status = UART002_FAIL;" + NL + " *\t UART002_LocalStructType TxChn;" + NL + " *\t UART002_LocalStructureInit(&UART002_Handle0,&TxChn,0x0001);" + NL + " *\t TxChn.DataLen = 12;" + NL + " *\t TxChn.pBuffer = &Data[0];" + NL + " *" + NL + " *\t while(1)" + NL + " *\t {" + NL + " *\t  //osDelay(1000);" + NL;
  protected final String TEXT_16 = " *\t\tStatus = UART002_StartTransmission(&TxChn,1000);" + NL + " *\t\tif(Status == UART002_TIMEOUT)" + NL + " *\t\t{" + NL + " *\t\t\tStatus = UART002_FAIL;" + NL + " *\t\t}" + NL + " *\t\telse" + NL + " *\t\t{" + NL + " *\t\t\tStatus = UART002_WaitForCompletion(&TxChn,1000);" + NL + " *\t\t\tif(Status != UART002_TIMEOUT)" + NL + " *\t\t\t{" + NL + " *" + NL + " *\t\t\t\tStatus = UART002_GetStatus(&TxChn);" + NL + " *\t\t\t\tif(Status != UART002_TRANSFER_SUCCESS)" + NL + " *\t\t\t\t{" + NL + " *\t\t\t\t\t\tStatus = UART002_FAIL;" + NL + " *\t\t\t\t}" + NL + " *\t\t\t}" + NL + " *\t\t}" + NL + " *\t }" + NL + " * }" + NL + " *\t" + NL + " *  int main (void)" + NL + " *  {" + NL + " *     " + NL + " *     DAVE_Init();" + NL + " *" + NL + " *    // Create thread X " + NL + " *    threadA_id = osThreadCreate(osThread(threadA), NULL);" + NL + " *" + NL + " *    osKernelStart();" + NL + " *" + NL + " *    while(1)" + NL + " *    {" + NL + " *\t     osDelay(1000);" + NL + " *    }" + NL + " *  }" + NL + " * @endcode<BR> </p>" + NL + " *" + NL + " */" + NL + "status_t UART002_WaitForCompletion(const UART002_LocalStructType* Config, time_t Timeout);" + NL + "" + NL + "" + NL + "/**" + NL + " * This function gets the result of  the transfer operation which was" + NL + " *           scheduled earlier." + NL + " *" + NL + " * @param[in]  Config Local structure object." + NL + " *" + NL + " * @return     status_t <BR>" + NL + " *             UART002_IDLE  \t\t\t: if Uart is IDLE<BR>" + NL + " *             UART002_TRANSFER_SUCCESS : Uart transmit or receive is successfull<BR>" + NL + " *             UART002_TRANSFER_FAILED \t: Uart transmit or receive failed<BR>" + NL + " *" + NL + " * <b>Reentrant: YES </b><BR>" + NL + " * @code" + NL + " * #include <DAVE3.h>" + NL + " *" + NL + " * // Forward reference " + NL + " * void threadA (void const *argument);" + NL + " *" + NL + " * // Thread IDs" + NL + " * osThreadId threadA_id;" + NL + " *" + NL + " *" + NL + " * //Thread definitions " + NL + " * osThreadDef(threadA, osPriorityNormal, 1, 0);" + NL + " * // HELLO WORLD" + NL + " * uint8_t Data[12] = {0x48,0x45,0x4C,0x4C,0x4F,0x20,0x57,0x4F,0x52,0x4C,0x44,0x20};" + NL + " *  " + NL + " * void threadA(void const *argument)" + NL + " * {" + NL + " *\t status_t Status = UART002_FAIL;" + NL + " *\t UART002_LocalStructType TxChn;" + NL + " *\t UART002_LocalStructureInit(&UART002_Handle0,&TxChn,0x0001);" + NL + " *\t TxChn.DataLen = 12;" + NL + " *\t TxChn.pBuffer = &Data[0];" + NL + " *" + NL + " *\t while(1)" + NL + " *\t {" + NL + " *\t\tStatus = UART002_StartTransmission(&TxChn,1000);" + NL + " *\t\tif(Status == UART002_TIMEOUT)" + NL + " *\t\t{" + NL + " *\t\t\tStatus = UART002_FAIL;" + NL + " *\t\t}" + NL + " *\t\telse" + NL + " *\t\t{" + NL + " *\t\t\tStatus = UART002_WaitForCompletion(&TxChn,1000);" + NL + " *\t\t\tif(Status != UART002_TIMEOUT)" + NL + " *\t\t\t{" + NL + " *\t\t\t\tStatus = UART002_GetStatus(&TxChn);" + NL + " *\t\t\t\tif(Status != UART002_TRANSFER_SUCCESS)" + NL + " *\t\t\t\t{" + NL + " *\t\t\t\t\tStatus = UART002_FAIL;" + NL + " *\t\t\t\t}" + NL + " *\t\t\t}" + NL + " *\t\t}" + NL + " *\t }" + NL + " *" + NL + " * }" + NL + " *\t" + NL + " * int main (void)" + NL + " * {" + NL + " *   " + NL + " *   DAVE_Init();" + NL + " *" + NL + " *   // Create thread X " + NL + " *   threadA_id = osThreadCreate(osThread(threadA), NULL);" + NL + " *" + NL + " *   osKernelStart();" + NL + " *" + NL + " *   while(1)" + NL + " *   {" + NL + " *\t   osDelay(1000);" + NL + " *   }" + NL + " * }" + NL + " * @endcode<BR> </p>" + NL + " *" + NL + " */" + NL + "status_t UART002_GetStatus(const UART002_LocalStructType* Config);" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + " " + NL + "#include \"UART002_Conf.h\"" + NL + "" + NL + "#ifdef __cplusplus" + NL + "}" + NL + "#endif" + NL + "" + NL + "#endif /* UART002_H*/" + NL + "/*CODE_BLOCK_END*/";
  protected final String TEXT_17 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri = "app/uart002/0";
     String Baseuri = "app/uart002/";
     String Uarturi = "peripheral/usic/"; 
     String MappedUri = null; 
     String UnitInst = null; 
     String appInst  = null; 
    stringBuffer.append(TEXT_2);
     int Is1xDevice = -1; 
     Is1xDevice = ((app.getSoftwareId().substring(0,1).compareTo("1")==0)?1:0); 
    stringBuffer.append(TEXT_3);
     ArrayList<String> appsList7 = (ArrayList<String>)(app.getApps("app/uart002/"));
 for (String appIns : appsList7 ) {
 appInst = appIns.substring(appIns.lastIndexOf("/")+1);
     MappedUri = app.getMappedUri(Baseuri + appInst + "/channel"); 
     if((MappedUri != null) && (MappedUri != "")) { 
 UnitInst = MappedUri.substring(MappedUri .length()-11,MappedUri.indexOf("/channel/")); 
 int Unit = Integer.parseInt(UnitInst); 
     if(Is1xDevice == 0){ 
     int DmaMode = app.getIntegerValue(Baseuri + appInst +"/uart002_DMAOprModeTemp");
    if((DmaMode > 0)) {
    stringBuffer.append(TEXT_4);
    break;
    }
    stringBuffer.append(TEXT_5);
    }
     } 
     else { 
    stringBuffer.append(TEXT_6);
     } 
    } 
    stringBuffer.append(TEXT_7);
     if(Is1xDevice == 0){ 
    stringBuffer.append(TEXT_8);
    }
    stringBuffer.append(TEXT_9);
     if(Is1xDevice == 0){ 
    stringBuffer.append(TEXT_10);
    }
    stringBuffer.append(TEXT_11);
     if(Is1xDevice == 0){ 
    stringBuffer.append(TEXT_12);
    }
    stringBuffer.append(TEXT_13);
     if(Is1xDevice == 0){ 
    stringBuffer.append(TEXT_14);
    }
    stringBuffer.append(TEXT_15);
    stringBuffer.append(TEXT_16);
    stringBuffer.append(TEXT_17);
    return stringBuffer.toString();
  }
}
